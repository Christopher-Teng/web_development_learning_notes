# Webpack 从零入门到工程化实战

## 目录

- [Webpack 从零入门到工程化实战](#webpack-从零入门到工程化实战)
  - [目录](#目录)
  - [1-前言](#1-前言)
    - [1-1-Webpack-概述](#1-1-webpack-概述)
      - [1-1-1-什么是模块化](#1-1-1-什么是模块化)
      - [1-1-2-什么是工程化](#1-1-2-什么是工程化)
      - [1-1-3-Webpack-的主要功能](#1-1-3-webpack-的主要功能)
  - [2-Webpack-配置](#2-webpack-配置)
    - [2-1-webpack-cli-常用选项](#2-1-webpack-cli-常用选项)
    - [2-2-基础概念和常见配置项](#2-2-基础概念和常见配置项)
      - [2-2-1-配置文件](#2-2-1-配置文件)
      - [2-2-2-Webpack-常见名词解释](#2-2-2-webpack-常见名词解释)
      - [2-2-3-Webpack-常见配置项](#2-2-3-webpack-常见配置项)
    - [2-3-webpack-配置实战](#2-3-webpack-配置实战)
      - [2-3-1-Webpack-中使用-Babel-转换-JavaScript-代码](#2-3-1-webpack-中使用-babel-转换-javascript-代码)
      - [2-3-2-Webpack-中使用-TypeScript](#2-3-2-webpack-中使用-typescript)
      - [2-3-3-Webpack-中使用样式文件](#2-3-3-webpack-中使用样式文件)
        - [2-3-3-1-CSS](#2-3-3-1-css)
        - [2-3-3-2-CSS-预处理器](#2-3-3-2-css-预处理器)
        - [2-3-3-3-CSS-后处理器](#2-3-3-3-css-后处理器)
      - [2-3-4-Webpack-中使用-lint-工具](#2-3-4-webpack-中使用-lint-工具)
        - [2-3-4-1-JavaScript-检测](#2-3-4-1-javascript-检测)
        - [2-3-4-2-CSS-检测](#2-3-4-2-css-检测)
      - [2-3-5-Webpack-中管理静态资源](#2-3-5-webpack-中管理静态资源)
        - [2-3-5-1-引入图片](#2-3-5-1-引入图片)
        - [2-3-5-2-图片优化](#2-3-5-2-图片优化)
        - [2-3-5-3-CSS-Sprite-雪碧图](#2-3-5-3-css-sprite-雪碧图)
        - [2-3-5-4-其他资源](#2-3-5-4-其他资源)
      - [2-3-6-Webpack-中打包-HTML-和多页面配置](#2-3-6-webpack-中打包-html-和多页面配置)
        - [2-3-6-1-Webpack-处理-HTML](#2-3-6-1-webpack-处理-html)
        - [2-3-6-2-多页面配置](#2-3-6-2-多页面配置)
      - [2-3-7-Webpack-Dev-Server-本地开发服务](#2-3-7-webpack-dev-server-本地开发服务)
      - [2-3-8-Webpack-环境相关配置与配置文件拆分](#2-3-8-webpack-环境相关配置与配置文件拆分)
  - [3-Webpack-优化](#3-webpack-优化)
    - [3-1-体积优化](#3-1-体积优化)
      - [3-1-1-JavaScript](#3-1-1-javascript)
        - [3-1-1-1-压缩](#3-1-1-1-压缩)
        - [3-1-1-2-Scope-Hoisting](#3-1-1-2-scope-hoisting)
        - [3-1-1-3-其他代码级别优化技巧](#3-1-1-3-其他代码级别优化技巧)
      - [3-1-2-CSS](#3-1-2-css)
        - [3-1-2-1-CSS-导出](#3-1-2-1-css-导出)
        - [3-1-2-2-压缩](#3-1-2-2-压缩)
      - [3-1-3-图片资源优化](#3-1-3-图片资源优化)
    - [3-2-增强缓存命中率](#3-2-增强缓存命中率)
      - [3-2-1-浏览器缓存策略和-Webpack-缓存配置](#3-2-1-浏览器缓存策略和-webpack-缓存配置)
      - [3-2-2-提取依赖和-Runtime-到单独文件](#3-2-2-提取依赖和-runtime-到单独文件)
      - [3-2-3-Webpack-的-Runtime](#3-2-3-webpack-的-runtime)
      - [3-2-4-合理使用动态加载功能拆分代码](#3-2-4-合理使用动态加载功能拆分代码)
      - [3-2-5-多页面项目按照路由拆分代码](#3-2-5-多页面项目按照路由拆分代码)
    - [3-3-抽取公共代码](#3-3-抽取公共代码)
      - [3-3-1-splitChunks-默认配置](#3-3-1-splitchunks-默认配置)
      - [3-3-2-chunks](#3-3-2-chunks)
      - [3-2-3-cacheGroups](#3-2-3-cachegroups)
    - [3-4-构建速度优化](#3-4-构建速度优化)
      - [3-4-1-优化构建过程](#3-4-1-优化构建过程)
        - [3-4-1-1-减少查找过程](#3-4-1-1-减少查找过程)
        - [3-4-1-2-利用多线程提升构建速度](#3-4-1-2-利用多线程提升构建速度)
        - [3-4-1-3-预先编译](#3-4-1-3-预先编译)
        - [3-4-1-4-缓存](#3-4-1-4-缓存)
      - [3-4-2-优化压缩速度](#3-4-2-优化压缩速度)
    - [3-5-Tree-Shaking](#3-5-tree-shaking)
  - [4-Webpack-工程化最佳实践](#4-webpack-工程化最佳实践)
    - [4-1-NPM-Scripts](#4-1-npm-scripts)
    - [4-2-区分多环境配置](#4-2-区分多环境配置)
      - [4-2-1-通用配置](#4-2-1-通用配置)
      - [4-2-2-开发配置](#4-2-2-开发配置)
      - [4-2-3-生成配置](#4-2-3-生成配置)
      - [4-2-4-打包分析配置](#4-2-4-打包分析配置)
      - [4-2-5-配置文件管理](#4-2-5-配置文件管理)
    - [4-3-合理使用-splitChunks](#4-3-合理使用-splitchunks)
      - [4-3-1-变更频次](#4-3-1-变更频次)
      - [4-3-2-页面 Router](#4-3-2-页面-router)
      - [4-3-3-动静分离](#4-3-3-动静分离)
    - [4-4-多页应用-Entry-和-HTML-管理](#4-4-多页应用-entry-和-html-管理)
    - [4-5-指定-chunk-的-哈希值](#4-5-指定-chunk-的-哈希值)
    - [4-6-语法层面的最佳实践](#4-6-语法层面的最佳实践)
    - [4-7-其他-Webpack-配置的最佳实践](#4-7-其他-webpack-配置的最佳实践)
    - [4-8-其他方面最佳实践](#4-8-其他方面最佳实践)
  - [5-Webpack-使用实战](#5-webpack-使用实战)
    - [5-1-使用-PostCSS-打造移动适配方案](#5-1-使用-postcss-打造移动适配方案)
      - [5-1-1 视口单位](#5-1-1-视口单位)
      - [5-1-2-REM-和-REM-布局](#5-1-2-rem-和-rem-布局)
      - [5-1-3-使用-vw-rem-postcss-结合实现移动页面适配方案](#5-1-3-使用-vw-rem-postcss-结合实现移动页面适配方案)

## 1-前言

随着多年的发展，前端开发越来越模块化、组件化、工程化，其目的都是为了提升开发效率，由此而出现了许多问题，比如：

- 现在开发都是模块化开发，但是模块多了，模块之间的依赖管理究竟该怎么做？
- 页面复杂度提升后，多页面、多系统、多状态怎么管理，页面间的公共部分应该如何维护，难道还是复制粘贴吗？
- 团队扩大之后，团队合作怎么做，怎么解决多人研发中的性能、代码风格等问题？
- 权衡研发效率和产品迭代的问题

解决以上种种问题的一个途径就是围绕 Webpack 打造一个前端工程化解决方案。那么首先我们需要弄清：

- 什么是模块化开发？
- 为什么使用 Webpack？
- Webpack 中的配置有哪些，分别可以帮我们解决什么问题？
- Webpack 中的概念有哪些？
- 这些概念在 Webpack 内核实现和原理上是怎么实现的？
- 除了打包，我们还可以使用 Webpack 做什么？

后文中，我们会分别从三个阶段学习 Webpack：

1. Webpack 开发配置，这一阶段的目的是 Webpack 入门，应付日常开发配置
2. Webpack 内核原理，这一阶段的目的是深入理解 Webpack 的流程机制，可以帮助开发团队做一些源码级别的改造和探索
3. 工程化实践，这一阶段的目的是将 Webpack 的配置和原理融会贯通，可以借助 Webpack 打造自己的前端工程化解决方案

### 1-1-Webpack-概述

#### 1-1-1-什么是模块化

模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程，有多种属性，分别反映其内部特性。

模块化不是编程领域的特有概念，在我们的生活中也处处可见模块化，例如小时候家电(比如收音机、电视机)坏了都是拿到店里找老师傅修一修，而现在的家电都是模块化的，检测下哪里坏了直接更换个新的模块就可以了。模块化让我们的生化效率更高。

而前端开发中说的模块化一般特指 JavaScript 的模块，最常见的就是 Node.js 的 NPM 包，每个模块，可能是最小甚至最优的代码组合，也可能是为了解决某些问题，包括很多特定模块组合成的大模块。

当没有模块化是，大家写代码时常常会复制(copy)，当我们需要某个功能的代码时，先看看自己以前在哪个项目中写过，有写过，就 copy 过来改改直接用，但是 copy 多了，代码的可维护性就会下降。

模块化之后，我们考虑更多的是代码使用和维护成本的问题，因此出现了很多模块化的规范，常用的如：CommonJS、AMD、CMD、UMD、ES6
Module 等。

- CommonJS

  CommonJS 是 Node.js 广泛使用的一套模块化规范，是一种同步加载模块依赖的方式

  - require：引入一个模块
  - exports：导入一个模块
  - module：模块本身

- AMD

  AMD 是 JS 模块加载库 RequireJS 提出并且完善的一套模块化规范，是一种异步加载模块依赖的方式

  - id：模块 id
  - dependencies：模块依赖
  - factory：模块的工厂函数，即模块的初始化操作函数
  - require：引入一个模块

- CMD

  CMD 是国产库 SeaJS 提出来的一套模块规范

- UMD

  UMD 是兼容 CommonJS 和 AMD 的一套规范，目前多数模块的封装，既可以在 Node.js 环境运行又可以在 Web 环境运行，所以一般会采用 UMD 规范

- ES6 Module

  ES6 Module 是 ES6 推出的一套模块化规范

  - import：引入模块依赖
  - export：导出模块

除了 JavaScript 的模块化外，在 CSS 样式中也可以采用@import 的方式来引入自己依赖的模块，而在如 Less 和 Sass 这些 CSS 预处理器中，@import 还可以用来导入变量、函数和 Mixin 等。

> 前端开发中常常使用组件化，模块化一般指的是可以被抽象封装的最小或最优代码集合，解决的是功能耦合问题，而组件化则更像是模块化的进一步封装，根据业务特点或者不同的使用场景封装出具有一定功能特性的独立整体，而且前端提到组件化时一般都是指具有模板、样式和 JS 交互的 UI 组件。

#### 1-1-2-什么是工程化

当 Web 应用越来越复杂的时候，开发中会更多的遇到例如如何处理模块依赖、多页面多系统多状态如何处理、团队合作怎么处理、多人研发时性能和代码风格怎么处理、怎么平衡研发效率和产品迭代等等问题，这些问题需要使用软件工程来解决。

在前端工程化早期，是以 Grunt、Gulp 等构建工具为主的阶段，主要解决重复任务的问题，面向的是流程和结果，它们将某些功能拆解成固定步骤的任务，然后编写工具来解决，例如：图片压缩、地址添加 hash、替换等，都是固定套路的重复工作。主要工作模式是：遍历源文件 => 匹配规则 => 打包，这个过程中并不关心打包的资源页面到底有没有使用，因此无法做到按需加载。

而现阶段作为主流构建工具的 Webpack 是面向 JS 模块的打包工具，从模块化依赖打包开始，利用强大的插件机制，逐渐解决前端资源依赖管理问题，依附社区力量逐渐进化成一套前端工程化解决方案。Webpack 本质上是一个 JS 静态模块打包器，在 Webpack 处理源文件时，会先在内部创建一个依赖图，用于映射项目需要的每个模块，然后将所有这些依赖生成一个或多个 bundle。Webpack 的工作模式是：从入口文件开始，经过模块依赖加载、分析然后完成打包，在这些步骤中可以针对性的做一些解决方案，达到按需加载，例如 code split(拆分公共代码)。

#### 1-1-3-Webpack-的主要功能

- 模块化打包，一切皆模块，JS 是模块，CSS 是模块，图片等等也都是模块
- 语法转换，比如 ES6 转 ES5、TypeScript 等
- 预(后)处理器编译，比如 Less、Sass、PostCSS 等
- 项目优化，比如图片压缩等
- 解决方案封装，通过强大的 loader 和插件机制，可以完成解决方案的封装，比如 PWA(Progressive Web Apps 渐进式 Web 应用，运用现代的 Web
  API 以及传统的渐进式增强策略来创建跨平台的 Web 应用程序，让页面应用呈现和原生应用相似的体验)
- 流程对接，比如测试流程、语法检测等

## 2-Webpack-配置

### 2-1-webpack-cli-常用选项

- --progress
  --colors：当项目逐渐变大或者使用生产环境编译打包时，打包时间会变长，使用该配置参数可以在编译打包过程中输出带有进度和颜色的内容
- --display-error-details：打包出现问题时，使用该配置参数可以将错误详情显示出来
- --watch：如果不想每次修改模块后都重新编译打包，可以使用该配置参数开启监听模式，内有变化的模块会被缓存到内存中，所以监听模式的整体速度很快
- -d 或-p：分别代表使用常用的开发环境和生产环境打包
- --config：指定配置文件
- --mode：指定打包环境，取值为 development 和 production，分别代表开发环境和生产环境
- --json：以 json 格式输出打包结果，并且可以指定将结果写入文件，例如 webpack --json > stats.json
- --progress：显示打包进度
- --color,--colors/--no-color,--no-colors：控制台输出内容是否开启颜色
- --hot：开启 Hot Module Replacement(热模块更新)
- --profile：详细输出每个环节的用时，方便排查打包速度瓶颈

### 2-2-基础概念和常见配置项

#### 2-2-1-配置文件

Webpack 是可配置的模块打包工具，可以通过修改 Webpack 的配置文件(webpack.config.js)来对 Webpack 进行配置，Webpack 的配置文件遵循 Node.js 的 CommonJS 模块规范

Webpack 不仅仅支持 js 配置，还支持 ts、CoffeeScript 甚至 JSX 语法的配置，不同语言其实核心配置项都是不变的，只不过语法不同而已

除了配置文件的语法多样之外，对于配置的类型也是多样的，最常见的是直接作为一个对象来使用，除了对象，Webpack 还支持函数、Promise 和多配置数组

- 函数类型的 Webpack 配置

  如果我们只使用一个配置文件来区分生产环境(production)和开发环境(development)，则可以使用函数类型的 Webpack 配置，函数类型的配置必须返回一个配置对象，并且接受两个参数 env 和 argv，分别对应着环境对象和 webpack-cli 的命令行选项，例如：

  ```javascript
  module.exports = (env, argv) => {
    return {
      mode: env.production ? "production" : "development",
      devtool: env.production ? "source-maps" : "eval",
      plugins: [
        new TerserPlugin({
          terserOptions: {
            compress: argv["optimize-minimize"], // 只有传入-p 或--optimize-minimize时才会启用
          },
        }),
      ],
    };
  };
  ```

- Promise 类型的 Webpack 配置

  如果需要异步加载一些 Webpack 配置需要做的变量，那么可以使用 Promise 的方式来做，例如：

  ```javascript
  module.exports = () => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve({
          entry: "./app.js",
          /* ... */
        });
      }, 5000);
    });
  };
  ```

- 多配置数组

  在一些特定的场景，可能需要一次打包多次，而多次打包中有一些通用的配置，这时候可以使用配置数组的方式，将两次以上的 Webpack 配置以数组的形式导出，例如：

  ```javascript
  module.exports = [
    {
      mode: "production",
      // 配置1
    },
    {
      // 配置2
    },
    /* ... */
  ];
  ```

默认情况下，Webpack 会查找执行项目根目录下面的 webpack.config.js 作为配置文件，也可以通过在 webpack-cli 命令行中使用--config 来指定特定的配置文件，如果 Webpack 不是全局安装，则在使用时需要从项目目录下的 node_module/webpack/bin/webpack 执行，或者使用 npx
webpack 来执行

#### 2-2-2-Webpack-常见名词解释

- entry:项目入口文件
- module：开发中每一个文件都可以看做 module，模块不局限于 js，也包含 css、图片等
- chunk：代码块，一个 chunk 可以由多个模块组成
- loader：模块转化器，模块的处理器，对模块进行转换处理
- plugin：扩展插件，插件可以处理 chunk，也可以对最后的打包结果进行处理，可以完成 loader 完不成的任务
- bundle：最终打包完成的文件，一般就是和 chunk 一一对应的关系，bundle 就是对 chunk 进行编译、压缩、打包等处理后的产出

#### 2-2-3-Webpack-常见配置项

- mode 模式

  Webpack 从 4.0 版本开始引入 mode 配置，通过配置 mode=development 或者 mode=production 来指定是开发环境打包还是生产环境打包，默认使用生产环境打包，即 mode=production。mode 模式可以在配置文件中通过 mode 项设置，也可以从命令行使用--mode 参数设置

- Webpack-的入口(entry)和出口(output)

  > webpack 是一个模块打包工具，能够从一个需要处理的 javascript 文件开始，构建一个依赖关系图(dependency
  > graph)，该图映射了项目中每个模块，然后将这个依赖关系图输出到一个或多个 bundle 中

  从上面对 webpack 的描述中可以发现 webpack 有两个基本、核心的概念：entry 和 output，即入口和出口。Webpack 是从指定的入口文件(entry)开始，经过加工处理，最终按照 output 的设定输出固定内容的 bundle，在加工过程中主要使用 loader 和 plugin，其中 loader 是源代码的转换、处理，而 plugin 则解决 loader 处理不了的其他事情。

  - context

    要讲解 entry 和 output 之前，先要了解 **context**(上下文)，context 即项目打包的相对路径上下文，我们设置 entry 和 output 时的相对路径都是相对于 context 指定的路径，包括在 javascript 中引入模块也是从这个路径开始，由于 context 的作用，决定了 context 必须是一个绝对路径，当不进行特别指定时，context 的默认值是 process.cwd()，即当前项目的工作目录，所以实际开发中一般不需要配置 context

  - entry

    entry 支持多种类型，包括字符串、对象、数组。从作用上来说，包括单文件入口和多文件入口

    单文件入口的示例：

    ```javascript
    /* 使用简写方式 */
    module.exports = {
      entry: "path/to/my/entry/file.js",
      /* ... */
    };
    /* 使用对象方式 */
    module.exports = {
      entry: {
        main: "path/to/my/entry/file.js",
        /* ... */
      },
    };
    /* 使用数组方式 */
    // 使用数组时，webpack会自动生成另外一个入口模块，并将数组中每个元素指定的文件加载进来，并将最后一个文件的module.exports作为入口文件的module.exports导出，注意虽然数组中包含多个文件，但实际上这仍然是单文件入口
    module.exports = {
      entry: ["path/to/my/entry/file1.js", "path/to/my/entry/file2.js"],
      /* ... */
    };
    ```

    多文件入口的示例：

    ```javascript
    module.exports = {
      entry: {
        home: "path/to/my/entry/home.js",
        search: "path/to/my/entry/search.js",
        list: "path/to/my/entry/list.js",
      },
      /* ... */
    };
    ```

    多文件入口将会打包出对应的多个 bundle

  - output

    output 是指定了 entry 对应的文件，经过编译打包后输出的 bundle。output 常用的属性主要有 path(输出 bundle 的存放路径)、filename(输出 bundle 的名字)、publicPath(在浏览器中被引用的 url 地址)，当不指定 output 是，默认输出到 dist/main.js，即 output.path 等于 dist，output.filename 等于 main。

    一个 webpack 的配置可以有多个 entry，但是只能有一个 output，对于不同的 entry 可以通过指定 output.filename 占位符语法来区分，例如：

    ```javascript
    module.exports = {
      entry: {
        home: "path/to/my/entry/home.js",
        search: "path/to/my/entry/search.js",
        list: "path/to/my/entry/list.js",
      },
      output: {
        path: __dirname + "/dist",
        filename: "[name].js",
      },
    };
    ```

    其中，[name]就是占位符，对应 entry 中的 key，因此上面配置的最终输出是 dist/home.js、dist/search.js 和 dist/list.js。

    webpack 支持的占位符主要有：

    - [id]：模块标识符
    - [name]：模块名称
    - [hash]

      模块标识符的 hash，是整个项目的 hash 值，其根据每次编译内容计算得到，每次编译之后都会生成新的 hash，即修改任何文件都会导致所有文件的 hash 发生改变；在一个项目中虽然入口不同，但是 hash 是相同的；hash 无法实现前端静态资源在浏览器上长缓存，这时候应该使用 chunkhash

    - [chunkhash]

      chunk 内容的 hash，根据不同的入口文件（entry）进行依赖文件解析，构建对应的 chunk，生成相应的 hash；只要组成 entry 的模块文件没有变化，则对应的 hash 也是不变的，所以一般项目优化时，会将公共库代码拆分到一起，因为公共库代码变动较少的，使用 chunkhash 可以发挥最长缓存的作用

    - [contenthash]

      使用 chunkhash 存在一个问题，当在一个 JS 文件中引入了 CSS 文件，编译后它们的 hash 是相同的。而且，只要 JS 文件内容发生改变，与其关联的 CSS 文件 hash 也会改变，针对这种情况，可以把 CSS 从 JS 中使用 mini-css-extract-plugin 或 extract-text-webpack-plugin 抽离出来并使用 contenthash

    - [query]：模块的 query，例如文件名?后面的字符串

    - [function]：一个返回字符串作为 filename 的函数

    hash、chunkhash、contenthash 的长度都是可以通过[xxx:length]的语法来指定的(默认为 20)，例如 [hash:8]，并且多个占位符可以组合使用，例如：[name]-[hash:8]。

    output.publicPath 用于指定页面中的使用 script 标签和 link 标签时，src 和 href 中的文件路径，一般用于将静态资源存放于不同的域名或者 CDN 上时，例如：

    ```javascript
    module.exports = {
      output: {
        path: "path/to/my/public/assets",
        publicPath: "http://cdn.example.com/assets/",
      },
    };
    ```

    其中，path 指定了输出到本地磁盘的路径，而 publicPath 指定了实际上线到服务器后的 url 地址

    output 的一些其他属性简介如下：

    - output.library

      当我们打包的目的是生成一个共别人使用的库时，可以使用该属性指定库的名称，支持使用普通字符串和占位符。

    - output.libraryTarget

      使用 output.library 确定了库的名称之后，还可以使用 output.libraryTarget 指定库打包出来的规范，output.libraryTarget 取值范围为：var、assign、this、window、global、commonjs、commonjs2、commonjs-module、amd、umd、umd2、jsonp，默认是 var

      **注意：** libraryTarget=global 的时候，如果 target=node 才是 global，默认 target=web 下 global 为 window，保险起见可以使用 this

- externals

  externals 配置项用于去除输出的打包文件中依赖的某些第三方 js 模块（例如 jquery，vue 等等），减小打包文件的体积。该功能通常在开发自定义 js 库（library）的时候用到，用于去除自定义 js 库依赖的其他第三方 js 模块。这些被依赖的模块应该由使用者提供，而不应该包含在 js 库文件中。

  这里就有个重要的问题，使用者应该怎么提供这些被依赖的模块给我们的 js 库（library）使用呢？这就要看我们的 js 库的导出方式是什么，以及使用者采用什么样的方式使用我们的库。

  针对以上问题，可以做如下配置：

  - 默认的导出方式：output.libraryTarget=‘var’，使用者只能以 script 标签的形式引入我们的库，并且只能以全局变量的形式提供这些被依赖的模块

  - commonjs 的导出方式：output.libraryTarget=‘commonjs’，使用者只能按照 commonjs 的规范引入我们的库，并且被依赖模块需要按照 commonjs 规范引入

  - amd 的导出方式：output.libraryTarget=‘amd’，使用者只能按照 amd 规范引入，并且被依赖模块需要按照 amd 规范引入

  - umd 的导出方式：output.libraryTarget=‘umd’，使用者可以用 script 标签、commonjs、amd 引入，并且被依赖模块需要按照对应方式引入

  如果不是在开发一个 js 库，即没有设置 output.library, output.libraryTarget 等配置信息，那么我们生成的打包文件只能以 script 标签的方式在页面中引入，因此那些被去除的依赖模块也只能以全局变量的方式引入。

- target

  webpack 中可以通过设置 target 来指定构建目标，target 的值可以是 string 或者 function，常见的
  string 类型配置项如下：

  - web：默认，编译为类浏览器环境里可用
  - node：编译为类 Node.js 环境可用（使用 Node.js require 加载 chunk）
  - async-node：编译为类 Node.js 环境可用（使用 fs 和 vm 异步加载分块）
  - electron-main：编译为 Electron 主进程
  - electron-renderer：编译为 Electron 渲染进程
  - node-webkit：编译为 Webkit 可用，并且使用 jsonp 去加载分块。支持 Node.js 内置模块和 nw.gui 导入
  - webworker：编译成一个 WebWorker

  function 类型的值则会接受一个 compiler 作为参数，可以用来增加插件

- devtool

  devtool 用来控制怎么显示 sourcemap，
  通过 sourcemap 我们可以快速
  还原代码
  的错误位置，
  但是由于 sourcemap 包含的数据量较大，而且生成算法需要计算量支持，所以 sourcemap 的生成会消耗打包的时间，
  一般在实际项目中，推荐生产环境不使用或者使用 source-map（如果有 Sentry 这类错误跟踪系统），开发环境使用 cheap-module-eval-source-map

- resolve

  resolve 是用来帮助 webpack 查找依赖模块，或者替换依赖模块(例如针对开发环境和生产环境使用不同版本的 lib 等)

  resolve 常用配置如下：

  - extensions：resolve.extensions 是帮助 Webpack 解析扩展名的配置，默认值：['.wasm', '.mjs', '.js', '.json']

  - alias：通过设置 alias，一来可以快速查找模块，避免在引入模块时书写过长的路径名，而来可以为开发环境和生产环境配置不同的引入模块版本，而且 alias 支持在名称末尾添加$符号来缩小匹配范围，只命中以关键字结尾的导入语句。

    > alias 的名字可以使用如@ ! ~之类的特殊字符，实际使用中一般采用一种或者不同类型的模块使用一种特殊符号，以便和正常的模块引入区别开来

  - mainFields：有一些模块会针对不同的宿主环境提供多分代码，例如 ES5 版本、ES6 版本，浏览器版本、NodeJS 版本等，通过设置 mainFields 可以决定使用哪个版本的代码。不同的 target 下，mainFields 的默认值不同。默认的 target=web 下，mainFields 的默认值为['browser','module','main']

- module

  在 webpack 解析模块的同时，不同的模块需要使用不同类型的模块处理器来处理，这部分的设置就在 module 配置中。module 有两个配置：module.noParse 和 module.rules

  - noParse：通过配置该项，可以让 Webpack 忽略对部分没采用模块化的文件的递归解析和处理，这样做的好处是能提高构建性能

    > 这里一定要确定被排除出去的模块代码中不能包含 import、require、define 等内容，以保证 webpack 的打包包含了所有的模块，不然会导致打包出来的 js 因为缺少模块而报错
    >
    > 与 module.rules 配置项下的 parser 配置项的区别：因为 webpack 是以模块化的 JavaScript 文件为入口，所以内置了对模块化 JavaScript 的解析功能。支持 AMD、Commonjs、SystemJs、ES6。parse 属性可以更细粒度的配置哪些模块语法要解析，哪些不解析。parser 是语法层面的限制，noParse 只能控制哪些文件不进行解析。
    >
    > parser 的可用值有：
    > amd:false（禁用 AMD）
    > commonjs:false（禁用 CommonJS）
    > system:false（禁用 SystemJS）
    > harmony:false（禁用 ES6 modules）
    > requireInclude:false（禁用 require.include）
    > requireEnsure:false（禁用 require.ensure）
    > requireContext:false（禁用 require.context）
    > browserify:false（禁用 browserify）
    > requireJs:false（禁用 requirejs）

  - rules：module.rules 是在处理模块时，将符合规则条件的模块，提交给对应的处理器来处理，通常用来配置 loader，其类型是一个数组，数组里每一项都描述了如何去处理部分文件。每一项 rule 大致由三部分组成：
    - 条件匹配：通过 test、include、exclude 等配置来命中可以应用规则的模块文件。test 配置正则匹配需要处理的文件类型，include 和 exclude 配置需要包含或者排除的文件目录，exclude 的优先级高于 include 和 test
    - 应用规则：对匹配条件通过后的模块，使用 use 配置项来应用 loader，可以应用一个 loader 或者按照**从后往前**的顺序应用一组 loader，当然我们还可以分别给对应 loader 传入不同参数。loader 不仅可以通过配置文件来匹配命中的文件进行使用，还可以直接在文件中内联的使用。通过配置文件中的 options 选项可以给 loader 传入参数，或者也可以通过 query 查询字符串的形式在内联的使用 loader 时传入参数。
    - 重置顺序：一组 loader 的执行顺序默认是从后到前（或者从右到左）执行，通过 enforce 选项可以让其中一个 loader 的执行顺序放到最前（pre）或者是最后（post）

- plugin：plugin 是 Webpack 的重要组成部分，通过 plugin 可以解决 loader 解决不了的问题。Webpack 本身就是有很多插件组成的，所以内置了很多插件，我们可以直接通过 webpack 对象的属性来直接使用，例如：webpack.optimize.UglifyJsPlugin，除了内置的插件，我们也可以通过 NPM 包的方式来使用插件
  > loader 面向的是解决某个或者某类模块的问题，而 plugin 面向的是项目整体，解决的是 loader 解决不了的问题

### 2-3-webpack-配置实战

在 Webpack 中一切皆模块，我们不仅可以随心所欲的使用 CommonJS、AMD 和 ES6 Module，
还可以使用 Webpack 对 Module 的增强方法和属性。

- import()和神奇注释

  在 Webpack 中，import 不仅仅是 ES6 Module 的模块导入方式，还是一个类似 require 的函数，我们可以通过 import('path/to/module')的方式引入一个模块，import()返回的是一个 Promise 对象。

  相对于 import from 的静态分析打包语法，import()是动态打包语法，即我们的内容不是第一时间一次打包完成，而是通过异步的方式加载进来的，因此会产出多个文件。代码分割正是 webpack 进行代码结构组织，实现动态优化的一个重要功能。

  在 import()中还可以添加注释，目前支持的注释主要有：

  - webpackInclude：如果是 import 的一个目录，则可以指定需要引入的文件特性，例如只加载 json 文件：/\.json$/
  - webpackExclude：如果是 import 的一个目录，则可以指定需要过滤的文件，例如 /\.noimport\.json$/
  - webpackChunkName：这是 chunk 文件的名称
  - webpackPrefetch: 是否预取模块，及其优先级，可选值 true、或者整数优先级别，0 相当于 true，webpack 4.6+支持
  - webpackPreload: 是否预加载模块，及其优先级，可选值 true、或者整数优先级别，0 相当于 true，webpack 4.6+支持
  - webpackMode: 可选值 lazy/lazy-once/eager/weak
    - lazy：是默认的模式，为每个 import() 导入的模块，生成一个可延迟加载 chunk
    - lazy-once：生成一个可以满足所有 import() 调用的单个可延迟加载 chunk，此 chunk 将在第一次 import() 调用时获取，随后的 import() 调用将使用相同的网络响应
    - eager：不会生成额外的 chunk，所有模块都被当前 chunk 引入，并且没有额外的网络请求。仍然会返回 Promise，但是是 resolved 状态。和静态导入相对比，在调用 import() 完成之前，该模块不会被执行
    - weak：尝试加载模块，如果该模块函数已经以其他方式加载（即，另一个 chunk 导入过此模块，或包含模块的脚本被加载）。仍然会返回 Promise，但是只有在客户端上已经有该 chunk 时才成功解析。如果该模块不可用，Promise 将会是 rejected 状态，并且网络请求永远不会执行。当需要的 chunks 始终在（嵌入在页面中的）初始请求中手动提供，而不是在应用程序导航在最初没有提供的模块导入的情况触发，这对于 Server 端渲染（SSR，Server-Side Render）是非常有用的

  通过上面的神奇注释，import()不再是简单的 JavaScript 异步加载器，还是任意模块资源的加载器

- 资源文件的模块化处理

  Webpack 中的样式文件里，可以通过@import 直接引入其他样式文件，而 js 文件中则可以通过 import（包括 require）直接引入样式文件。

  除了样式文件外，其他诸如 html 文件、模板文件、甚至图片等等，都可以通过使用对应的 loader 将资源文件作为模块引入，例如：

  ```javascript
  const html = require("html-loader!./loader.html");
  console.log(html);
  ```

  其中的 html 实际上是引入的当前文件夹下 loader.html 文件的 string 片段

  ```javascript
  const render = require("ejs!./file.ejs");
  render(data);
  ```

  上面对 ejs 模板文件使用 ejs-loader 直接得到 render 函数

#### 2-3-1-Webpack-中使用-Babel-转换-JavaScript-代码

1. 安装依赖包

   安装开发依赖：

   ```bash
   npm i webpack babel-loader webpack-cli @babel/core @babel/preset-env @babel/plugin-transform-runtime -D
   ```

   将 runtime 作为依赖：

   ```bash
   npm i @babel/runtime -S
   ```

   安装指定版本的 core-js

   ```bash
    npm i core-js@3 -S
   ```

2. 编辑 webpack 配置文件

   ```javascript
   // webpack.config.js
   module.exports = {
     // ...
     module: {
       rules: [
         {
           test: /.js$/,
           use: [
             {
               loader: "babel-loader",
             },
           ],
         },
       ],
     },
     // ...
   };
   ```

3. 编辑 babel 配置文件

   ```json
   // .babelrc
   {
     "plugins": [
       [
         "@babel/plugin-transform-runtime",
         {
           "corejs": false, // 默认值，可以不写
           "helpers": true, // 默认，可以不写
           "regenerator": false, // 通过 preset-env 已经使用了全局的 regeneratorRuntime, 不再需要 transform-runtime 提供的 不污染全局的 regeneratorRuntime
           "useESModules": true // 使用 es modules helpers, 减少 commonJS 语法代码
         }
       ]
     ],
     "presets": [
       [
         "@babel/preset-env",
         {
           "targets": {}, // 这里是targets的配置，根据实际browserslist设置
           "corejs": 3, // 添加core-js版本
           "modules": false, // 模块使用 es modules ，不使用 commonJS 规范
           "useBuiltIns": "usage" // 默认 false, 可选 entry , usage
         }
       ]
     ]
   }
   ```

4. 编辑 Browserslist 配置文件

   实际开发项目中，我们肯定知道自己的项目运行在什么浏览器内，比如我们做移动开发，不可能需要兼容 IE10 以下的浏览器，所以如果我们做了很多兼容 IE10 以下浏览器的工作，那么就是无用功。通过设置目标浏览器，可以让我们的代码更有针对性的输出兼容性代码（包括 CSS 前缀、JS 的 Polyfill 等），而不是无脑的全部兼容。

   Browserslist 就是帮助我们来设置目标浏览器的工具。Browserslist 被广泛的应用到 Babel、postcss-preset-env、autoprefixer 等开发工具上， Browserslist 实际上就是声明了一段浏览器的集合，我们的工具可以根据这段集合描述，针对性的输出兼容性代码。

   Browserslist 的配置可以放在 package.json 中，也可以单独放在配置文件.browserslistrc 中。所有的工具都会主动查找 browserslist 的配置文件，根据 browserslist 配置找出对应的目标浏览器集合。

#### 2-3-2-Webpack-中使用-TypeScript

1. 安装 ts-loader

   ```bash
     npm i ts-loader -D
   ```

2. 编辑 Webpack 配置文件

   ```javascript
   module.exports = {
     // ...
     module: {
       rules: [
         {
           test: /\.ts$/,
           use: [
             {
               loader: "ts-loader",
             },
           ],
         },
       ],
     },
     // ...
   };
   ```

3. 编辑 TypeScript 配置文件

   为了方便编译器和编辑器识别 TypeScript 项目，TypeScript 约定了 tsconfig.json 文件来存储项目配置，编译器会从项目目录下一次往上查找该文件，因此可以在项目根目录下创建 tsconfig.json 文件来配置 TypeScript 项目。

#### 2-3-3-Webpack-中使用样式文件

##### 2-3-3-1-CSS

1. css-loader

   安装依赖包：

   ```bash
     npm i css-loader -D
   ```

   编辑 webpack 配置文件：

   ```javascript
   // webpack.config.js
   module.exports = {
     // ...
     module: {
       rules: [
         {
           test: /\.css$/,
           use: [
             {
               loader: "css-loader",
             },
           ],
         },
       ],
     },
   };
   ```

   这样一来，在 js 文件中引入 css 文件，css 就会被转换成字符串，可以被 js 直接使用。

2. style-loader

   style-loader 可以将打包好的 css 代码以 style 标签的形式插入到 html 文件中

   安装依赖包：

   ```bash
     npm i style-loader -D
   ```

   编辑 webpack 配置文件，注意 style-loader 需要配合 css-loader 使用，并且要在 css-loader 后面使用

   ```javascript
   // webpack.config.js
   module.exports = {
     // ...
     module: {
       rules: [
         {
           test: /\.css$/,
           use: [
             {
               loader: "style-loader",
             },
             {
               loader: "css-loader",
             },
           ],
         },
       ],
     },
   };
   ```

3. mini-css-extract-plugin

   以 style 标签的形式将 css 代码嵌入进 html 文件不符合样式与结构分离原则，因此可以使用 mini-css-extract-plugin 将打包好的 css 代码以 link 标签的方式引入 html

   安装依赖包：

   ```bash
     npm i mini-css-extract-plugin -D
   ```

   编辑 webpack 配置文件，注意需要同时使用 loader 和 plugin，并且 mini-css-extract-plugin 的 loader 要在 css-loader 后面，替换 style-loader 的位置

   ```javascript
   // webpack.config.js
   const MiniCssExtractPlugin = require("mini-css-extract-plugin");
   module.exports = {
     // ...
     module: {
       rules: [
         {
           test: /\.css$/,
           use: [
             {
               loader: MiniCssExtractPlugin.loader,
             },
             {
               loader: "css-loader",
             },
           ],
         },
       ],
     },
     plugins: [
       new MiniCssExtractPlugin({
         filename: "[name].css",
         chunkFilename: "[id].css",
       }),
     ],
   };
   ```

4. CSS Modules

   CSS Modules 指的是所有的 CSS 类名及其动画名都只是局部作用域的 CSS 文件。CSS Modules 主要解决的问题有：

   - 解决 CSS 类都是全局的，容易造成全局污染（样式冲突）
   - JS 和 CSS 共享类名
   - 可以方便的编写出更加健壮和扩展方便的 CSS

   下面是一个使用 CSS Modules 的例子：

   ```css
   /* app.css */
   .element {
     background-color: blue;
     color: white;
     font-size: 24px;
   }
   ```

   ```javascript
   // app.js
   import styles from "./app.css";

   let element = `
   
      <div class="${styles.element}">
        <p>CSS Modules</p>
      </div>
    `;
   document.write(element);
   ```

   通过 CSS Modules，可以在 JS 中直接将 CSS 的类名当作对象使用，要打开 CSS Modules 功能，只需在 css-loader 配置中增加 modules 选项

   ```javascript
   // webpack.config.js
   module.exports = {
     // ...
     module: {
       rules: [
         {
           test: /\.css$/,
           use: [
             {
               loader: "css-loader",
               options: {
                 modules: true,
               },
             },
           ],
         },
       ],
     },
   };
   ```

##### 2-3-3-2-CSS-预处理器

1. Less

   安装依赖包：

   ```bash
   npm i less-loader -D
   ```

   编辑 webpack 配置文件：

   ```javascript
   // webpack.config.js
   module.exports = {
     // ...
     module: {
       rules: [
         {
           test: /\.less$/,
           use: [
             {
               loader: "style-loader",
             },
             {
               loader: "css-loader",
               options: {
                 modules: true,
               },
             },
             {
               loader: "less-loader",
             },
           ],
         },
       ],
     },
   };
   ```

2. Sass

   安装依赖包：

   ```bash
   npm i node-sass sass-loader -D
   ```

   编辑 webpack 配置文件：

   ```javascript
   // webpack.config.js
   module.exports = {
     // ...
     module: {
       rules: [
         {
           test: /\.s(a|c)ss$/,
           use: [
             {
               loader: "style-loader",
             },
             {
               loader: "css-loader",
               options: {
                 modules: true,
               },
             },
             {
               loader: "sass-loader",
             },
           ],
         },
       ],
     },
   };
   ```

   注意，less-loader 和 sass-loader 需要在 css-loader 之前使用，因为要先将 less 或 sass 转换成合法的 css，然后才能使用 css-loader 进行处理，以上示例中 style-loader 也可以根据实际情况替换成使用 mini-css-extract-plugin

##### 2-3-3-3-CSS-后处理器

PostCSS 是一个使用 JavaScript 插件来转换 CSS 的工具，PostCSS 核心是将 CSS 解析成 AST，然后通过各种插件做各种转换，最终生成处理后的新 CSS，跟 Babel 在功能和实现上都类似，例如可以自动添加浏览器前缀，压缩代码以及使用增强 CSS 语法等

1. 安装依赖包：

   ```bash
   npm i postcss-loader -D
   ```

2. 编辑 webpack 配置文件

   ```javascript
   // webpack.config.js
   module.exports = {
     // ...
     module: {
       rules: [
         {
           test: /\.css$/,
           use: [
             {
               loader: "style-loader",
             },
             {
               loader: "css-loader",
               options: {
                 modules: true,
                 importLoader: 1,
               },
             },
             {
               loader: "postcss-loader",
             },
           ],
         },
       ],
     },
   };
   ```

   如果使用了预处理器，以 Less 为例，Sass 用法类似：

   ```javascript
   module.exports = {
     // ...
     module: {
       rules: [
         {
           test: /\.less$/,
           use: [
             {
               loader: "style-loader",
             },
             {
               loader: "css-loader",
               options: {
                 modules: true,
                 importLoader: 2,
               },
             },
             {
               loader: "postcss-loader",
             },
           ],
         },
       ],
     },
   };
   ```

   注意，postcss-loader 要在 css-loader 以及预处理器 loader 之前使用，css-loader 中的 importLoader 选项主要解决当在一个样式文件中使用@import 引入另一个样式文件时，不能正确使用 postcss 进行处理的问题。importLoader 默认值为 0，即不设置该项时，通过@import 引入的样式代码不会被 postcss 处理，设为 1 则直接在 css 文件中通过@import 引入的样式代码会被 postcss 处理，当使用预处理器时，则设为 2，可以是 less 或 scss 中通过@import 引入的样式代码也被 postcss 处理。

   css-loader 的 importLoader 选项也可以替换为使用 postcss 的插件 postcss-import 来达到相同效果。

3. 配置 PostCSS

   postcss 可以通过三种方式进行配置，postcss.config.js、postcss-loader 的 options 配置项以及直接在 package.json 中添加 postcss 属性，下面以使用 postcss.config.js 为例，该文件一般放置于项目根目录下，使用 Node.js 模块写法：

   ```javascript
   // postcss.config.js
   const autoprefixer = require("autoprefixer");
   const postcssImport = require("postcss-import");
   module.exports = {
     plugins: [postcssImport(), autoprefixer(["IE 10"])],
   };
   ```

   postcss 常用插件举例：

   - autoprefixer

     autoprefixer 就是给 css 补齐各种浏览器私有的前缀，例如-webkit、-moz、-ms 等，当然还会处理各种兼容性问题，比如 flex 语法，不能简单添加-webkit 就解决，还需要处理成-webkit-box 这类老版本的标准。Autoprefixer 的主要参数就是 browserslist，即需要代码支持的浏览器列表。

   - postcss-preset-env

     postcss-preset-env 是跟 babel 的 preset-env 类似的功能，通过它可以安心的使用最新的 CSS 语法来写样式，不用关心浏览器兼容性，浏览器兼容的问题交给了 postcss-preset-env 和 WebPack，在打包构建的时候，会根据不同的配置输出对应支持的 CSS 文件。postcss-preset-env 支持的 CSS 标准，完全可以媲美 CSS 预处理器的功能，所以如果对 cssnext 新的标准比较熟悉，可以直接用新标准来写样式

   - cssnano

     cssnano 是一个强大的 PostCss 插件，在 CSS 压缩优化中会经常被用到，它有别于常规的 CSS 压缩工具只是去除空格注释，还支持根据 CSS 语法解析结果智能压缩代码

#### 2-3-4-Webpack-中使用-lint-工具

##### 2-3-4-1-JavaScript-检测

1. eslint

   安装依赖包：

   ```bash
     npm i eslint eslint-formatter-friendly eslint-loader -D
   ```

   > eslint-formatter-friendly 可以是 eslint 的错误报告更规范好看一些

   生成 eslint 配置文件：

   ```bash
   eslint --init
   ```

   eslint 有一些常用的规范，比如 Airbnb 的 js 规范、标准规范 JavaScript Standard Style Guide 以及 Google 的规范，要使用某一种规范，需要先安装依赖包然后在.eslintrc.json 配置文件中对 extends 选项进行相应配置：

   ```bash
   npm i eslint-config-airbnb eslint-config-standard eslint-config-google -D
   ```

   ```json
   // .eslintrc.json
   {
     // ...
     "extends": "google"
     // ...
   }
   ```

   eslint 的 rules 一般根据团队的规范来制定，除此之外推荐进行以下配置：

   ```json
   // .eslintrc.json
   {
     // ...
     "rules": {
       //禁止console
       "no-console": 2,
       // 禁止debugger
       "no-debugger": 2,
       //禁止alert
       "no-alert": 2,
       // 不用的var要删除，手动tree shaking
       "no-unused-vars": 2,
       //禁止未经定义就使用
       "no-undef": 2
     }
     // ...
   }
   ```

   > eslint 的报错级别分三档，off/warn/error，分别对应数字 0/1/2

   编辑 webpack 配置文件：

   ```javascript
   // webpack.config.js
   module.exports = {
     // ...
     module: {
       rules: [
         {
           test: /\.js$/,
           // 只对src目录下的源码进行检测
           include: [path.resolve(__dirname, "src")],
           use: [
             {
               loader: "eslint-loader",
             },
           ],
           // 单独为eslint配置一条rule，所以要保证先检测代码风格，在进行babel转换之类的处理
           enforce: "pre",
           options: {
             // 这里的配置项参数将会被传递给eslint cli
             formatter: require("eslint-formatter-friendly"),
           },
         },
       ],
     },
   };
   ```

   > 对于 TypeScript 可以使用 tslint-loader

##### 2-3-4-2-CSS-检测

检测 CSS 语法使用 stylelint，官方推荐的代码风格规范有两个：stylelint-config-recommended 和 stylelint-config-standard，还可以选择使用 stylelint-order 插件，该插件的作用是强制我们在写 CSS 的时候按照某个顺序来编写。例如先写定位，再写盒模型，再写内容区样式，最后写 CSS3 相关属性。这样可以极大的保证我们代码的可读性和风格统一。

首先安装依赖包：

```bash
npm i stylelint stylelint-webpack-plugin -D
```

然后配置 stylelint，使用.stylelintrc.json 配置文件，一般放在项目根目录下，其配置项和 eslint 配置文件类似，只要使用 extends 和 rules 进行配置。

最后，编辑 webpack 配置文件

```javascript
// webpack.config.js
const StyleLintPlugin = require("stylelint-webpack-plugin");
module.exports = {
  // ...
  plugins: [new StyleLintPlugin()],
  // ...
};
```

stylelint-webpack-plugin 使用时可以传入配置参数，其中有 2 个和 webpack 的编译相关：

- emitErrors：默认是 true，将遇见的错误信息发送给 webpack 的编辑器处理
- failOnError：默认是 false，如果是 true 遇见 StyleLint 报错则终止 Webpack 编译

#### 2-3-5-Webpack-中管理静态资源

##### 2-3-5-1-引入图片

前端日常开发中，引入图片主要有三种方式：

- HTML 中通过 img 标签引入
- CSS 中通过 src 引入
- JS 中使用图片的 url 或者内容（比如使用 canvas）

在 webpack 中可以使用 loader 来引入图片，图片引入以后可以直接在 css 或者 html 中使用相对路径引用图片，而且 webpack 常用配置中的 resolve.alias 也可以用于在 css 或者 html 中引用图片，例如：

```javascript
// webpack.config.js
module.exports = {
  // ...
  resolve: {
    alias: {
      "@assets": path.resolve(__dirname, "src/assets"),
    },
  },
  // ...
};
```

```html
<img src="~@assets/img/foo/bar.png" />
```

```css
.bg-img {
  background: url(~@assets/img/foo/bar.png) no-repeat;
}
```

注意在 CSS 和 HTML 中使用 alias 时，**需要在 alias 前面加上~**

> **_Tips_**：HTML 中使用静态资源时，还需要使用 html-loader，不然也不会处理静态资源的路径问题

webpack 对图片的识别和打包处理主要通过两个 loader 来完成：file-loader 和 url-loader，两者在很大程度上可以互换使用，主要的区别如下：

- file-loader：能够根据配置项复制使用到的资源（不局限于图片）到构建之后的文件夹，并且能够更改对应的链接
- url-loader：包含 file-loader 的全部功能，并且能够根据配置将符合配置的文件转换成 Base64 方式引入，将小体积的图片 Base64 引入项目可以减少 http 请求，也是一个前端常用的优化方式

要使用对应的 loader，仍然要先安装依赖包：

```bash
npm i file-loader url-loader -D
```

然后编辑 webpack 配置文件：

```javascript
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.(png|jpe?g|svg|gig)$/,
        use: [
          {
            loader: "file-loader",
            // 或者使用url-loader
          },
        ],
      },
    ],
  },
  // ...
};
```

url-loader 默认会将图片以 Base64 的方式引入，这样虽然能减少 http 请求数，但是过大的图片会显著增加 html 文件体积，因此应该限制使用 Base64 引入方式的图片的大小，可以通过配置 url-loader 的 limit 选项来实现：

```javascript
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.(png|jpe?g|svg|gif)$/,
        use: [
          {
            loader: "url-loader",
            options: {
              limit: 3 * 1024, // 限制3k以内的图片才会使用Base64的方式进行引入
            },
          },
        ],
      },
    ],
  },
  // ...
};
```

一般静态资源上线的时候都会放到 CDN，可以通过 webpack 配置文件中的 output.publicPath 配置 CDN 域名和路径，这样 webpack 在打包的时候会自动替换路径

另外，针对 SVG 图片也可以还可以使用 svg-url-loader，其工作原理类似 url-loader，区别是使用 URL encoding 而不是 Base64 文件编码，因为 SVG 文件是纯文本，使用方式如下：

```javascript
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.svg$/,
        use: [
          {
            loader: "svg-url-loader",
            options: {
              // 限制文件大小
              limit: 3 * 1024,
              // 移除url中的引号，大多数情况下都不是必需的
              noquotes: true,
            },
          },
        ],
      },
    ],
  },
  // ...
};
```

##### 2-3-5-2-图片优化

在 Webpack 中可以借助 img-webpack-loader 来对使用到的图片进行优化。它支持 JPG、PNG、GIF 和 SVG 格式的图片。

首先，安装依赖包：

```bash
npm i image-webpack-loader -D
```

注意，image-webpack-loader 并不能将图片嵌入应用中，所以必须配合使用 url-loader 或 svg-url-loader

接下来编辑 webpack 配置文件：

```javascript
// webpack.config.js
module.exports={
  // ...
  module:{
    rules:[
      {
        test:/\.(png|jpe?g|svg|gif)$/,
        use:[
          {
            loader:'image-webpack-loader'
          }
        ],
        enforce:'pre
      }
    ]
  }
  // ...
}
```

使用 enforce:'pre'选项保证先对图片进行优化，然后再进行引入。image-webpack-loader 的默认配置就已经可以满足日常开发中图片的优化压缩了。

##### 2-3-5-3-CSS-Sprite-雪碧图

使用 postcss 的插件 postcss-sprites 可以自动生成雪碧图

首先安装依赖包：

```bash
npm i postcss-loader postcss-sprites -D
```

然后配置 postcss：

```javascript
// postcss.config.js
const postcssSprites = require("postcss-sprites");

module.exports = {
  plugins: [
    postcssSprites({
      // 在这里指定哪个目录下的图片会被主动应用css sprite，避免所有图片都被处理成雪碧图
      spritePath: "./src/assets/img",
    }),
  ],
};
```

最后编辑 webpack 配置文件，加入 postcss-loader，注意使用顺序，要在其他样式文件 loader 之前使用。

使用 postcss-sprites 之后，webpack 打包后的 CSS 文件中，应用了 css sprite 的图片会自动替换成雪碧图的写法。

##### 2-3-5-4-其他资源

- 字体、富媒体

  对于字体和富媒体等资源，直接使用 file-loader 或者 url-loader 即可，不使用 Base64 的情况可以直接采用 file-loader，需要的话就采用 url-loader。

  当要处理的文件格式有多种时，可以使用[ext]来配置输出的文件扩展名，例如：

  ```javascript
  // webpack.config.js
  module.exports={
    // ...
    module:{
      rules:[
        {
          test:/\.(eot|woff|ttf|woff2|appcache|mp4|pdf)(\?|$)/,
          use:[
            {
              loader:'file-loader'
            }
          ],
          query:{
            // 这么多不同文件类型，所以需要配置[ext]
            name:'assets/[name].[hash:7].[ext]
          }
        }
      ]
    }
    // ...
  }
  ```

- 数据

  如果我们项目需要加载的类似 JSON、CSV、TSV 和 XML 等数据，那么我们需要单独给它们配置相应的 loader。对 JSON 的支持实际上是内置的，要导入 CSV，TSV 和 XML，可以使用 csv-loader 和 xml-loader。

  首先，安装依赖包：

  ```bash
  npm i csv-loader xml-loader -D
  ```

  然后编辑 webpack 配置文件：

  ```javascript
  // webpack.config.js
  module.exports = {
    // ...
    module: {
      rules: [
        {
          test: /\.(csv|tsv)$/,
          use: [
            {
              loader: "csv-loader",
            },
          ],
        },
        {
          test: /\.xml$/,
          use: [
            {
              loader: "xml-loader",
            },
          ],
        },
      ],
    },
    // ...
  };
  ```

#### 2-3-6-Webpack-中打包-HTML-和多页面配置

##### 2-3-6-1-Webpack-处理-HTML

要让 webpack 处理 HTML，只需要使用 html-webpack-plugin 就可以：

首先，安装依赖包：

```bash
npm i html-webpack-plugin -D
```

然后编辑 webpack 配置文件：

```javascript
// webpack.config.js
const HtmlWebpackPlugin = require("html-webpack-plugin");
module.exports = {
  // ...
  plugins: [new HtmlWebpackPlugin()],
  // ...
};
```

通过以上配置，会在 dist 目录下生成一个 index.html 文件，其中已经包含了 entry 中的 js 文件。

还可以通过给 html-webpack-plugin 传递参数 title 和 filename 来指定生成的 html 文件的 title 值和文件名，例如：

```javascript
// webpack.config.js
const HtmlWebpackPlugin = require("html-webpack-plugin");
module.exports = {
  // ...
  plugins: [
    new HtmlWebpackPlugin({
      title: "Foo",
      filename: "bar.html",
    }),
  ],
  // ...
};
```

除了让 webpack 生成默认内容的 html 文件外，还可以通过给 html-webpack-plugin 传递参数 template 指定通过使用自定义的 html 模板文件来生成打包产出的 html 文件，例如：

```javascript
// webpack.config.js
const HtmlWebpackPlugin = require("html-webpack-plugin");
module.exports = {
  // ...
  plugins: [
    new HtmlWebpackPlugin({
      template: "./src/templates/index.html",
    }),
  ],
  // ...
};
```

webpack 还支持使用 JavaScript 模板引擎来创建 html-webpack-plugin 的模板文件，以使用 pub 模板引擎为例：

首先要安装处理 pub 的 loader：

```bash
npm i pub-html-loader html-loader
```

然后，编辑 webpack 配置文件：

```javascript
// webpack.config.js
const HtmlWebpackPlugin = require("html-webpack-plugin");
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.pub$/,
        use: [
          {
            loader: "html-loader",
          },
          {
            loader: "pub-html-loader",
          },
        ],
      },
    ],
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: "./src/templates/index.pub",
    }),
  ],
  // ...
};
```

##### 2-3-6-2-多页面配置

1. 多 HTML 页面问题

   当需要生成多个 HTML 页面时，直接通过多次使用 html-webpack-plugin 实例化多个打包产出页面即可，下面以使用不同的模板生成多个页面为例：

   ```javascript
   // webpack.config.js
   const HtmlWebpackPlugin = require("html-webpack-plugin");
   const indexPage = new HtmlWebpackPlugin({
     template: "./src/templates/index.html",
     filename: "index.html",
   });
   const listPage = new HtmlWebpackPlugin({
     template: "./src/templates/list.html",
     filename: "list.html",
   });
   module.exports = {
     // ...
     plugins: [indexPage, listPage],
     // ...
   };
   ```

2. 多入口问题

   多次实例化 html-webpack-plugin 只能解决产出多页面的问题，但是多个 html 页面所引用的都是相同的 js 文件，如何解决多个 js 入口文件，而且入口文件还需要区分，即不同的 html 文件要引入不同的 js 文件呢？

   可以使用 html-webpack-plugin 的 chunks 参数和 excludeChunks 参数，chunks 参数指定当前页面包含哪些 chunks，而 excludeChunks 顾名思义，是排除哪些 chunks，要引入的 chunks 可以直接使用 entry 的 key ，如此便可以解决对应多入口，并且需要区分的情况，举例如下：

   ```javascript
   const HtmlWebpackPlugin = require("html-webpack-plugin");
   module.exports = {
     // ...
     entry: {
       index: "./src/index.js",
       list: "./src/list.js",
     },
     plugins: [
       new HtmlWebpackPlugin({
         template: "./src/templates/index.html",
         filename: "index.js",
         chunks: ["index"],
       }),
       new HtmlWebpackPlugin({
         template: "./src/templates/list.html",
         filename: "list.js",
         chunks: ["list"],
       }),
     ],
     // ...
   };
   ```

#### 2-3-7-Webpack-Dev-Server-本地开发服务

1. 命令行模式使用

   首先安装依赖包：

   ```bash
   npm i webpack-dev-server -D
   ```

   然后，可以通过命令行的方式启动 webpack-dev-server：

   ```bash
   npx webpack-dev-server
   ```

   执行 webpack-dev-server 之后，会读取 webpack 配置文件(默认是 webpack.config.js)，然后将文件打包到内存中(所以看不到 dist 文件夹的产生，即没有实际的产出文件)，然后打开 webpack-dev-server 的默认地址：localhost:8080 就可以看到文件目录或者页面(默认显示 index.html，如果没有则显示目录)。

   webpack-dev-server 命令行模式的常见参数有：

   ```bash
   # 修改端口号和host
   webpack-dev-server --port 3000 --host 127.0.0.1
   # 启动inline模式的自动刷新
   webpack-dev-server --hot --inline
   # 手动指定webpack config文件
   webpack-dev-server --config webpack.foo.js
   # 指定webpack的mode
   webpack-dev-server --mode development
   # 开启watch功能，文件发生变化时自动触发重新编译
   webpack-dev-server --watch
   # webpack-dev-server默认将工作目录(当前目录)作为基本目录，可以手动指定
   webpack-dev-server --content-base ./build
   ```

   还可以将 webpack-dev-server 放到 package.json 里面，通过执行 script 脚本启动，如下所示：

   ```json
   // package.json
   {
     // ...
     "scripts": {
       "dev": "webpack-dev-server --mode development --config webpack.config.dev.js --hot --inline --port 3000"
     }
     // ...
   }
   ```

2. 自动刷新

   webpack-dev-server 提供自动刷新页面的功能，方便开发中边写代码边观察执行情况，webpack-dev-server 支持两种模式的自动刷新页面：

   - iframe 模式：页面被放到一个 iframe 内，当发生变化时，会重新加载
   - inline 模式：将 webpack-dev-server 的重载代码添加到产出的 bundle 中

   两种模式都支持模块热替换(Hot Module Replacement)，HMR 的好处是只替换更新的部分，而不是整个页面重新加载，可以保持住页面的当前状态。

3. 与 Webpack 配置结合

   webpack-dev-server 被 webpack 作为内置插件对外提供，这样可以直接在对应的 webpack 配置文件中通过 devServer 属性来开启并配置，如下所示：

   ```javascript
   // webpack.config.js
   const path = require("path");
   module.exports = {
     // ...
     devServer: {
       contentBase: path.join(__dirname, "dist"),
       port: 3000,
     },
     // ...
   };
   ```

   > 要注意，在 webpack 的配置文件中通过 devServer 属性配置 webpack-dev-server 之后，在使用时还是需要通过 webpack-dev-server 命令来启动，而不是通过 webpack 命令，使用 webpack 命令时，会忽略 devServer 的内容而直接进行实际的打包

4. Hot Module Replacement

   HMR 即模块热替换，它可以在应用运行的时候，不需要刷新页面，而直接替换、增删模块。webpack 可以通过配置 webpack.HotModuleReplacementPlugin 插件来开启全局的 HMR，要开启 HMR 需要三步：

   1. 设置 devServer.hot=true,devServer.inline=true(默认)

      - devServer.hot=true 会给 entry 添加 webpack/hot/dev-serve 或者 webpack/hot/only-dev-serve(devServer.hotOnly=true)，这个是实现 HMR 的服务端代码
      - devServer.inline=true 会给 entry 添加 webpack-dev-server/client，这是通信客户端

   2. 在 webpack.config.js 中添加 plugins:new webpack.HotModuleReplacementPlugin()
   3. 修改入口文件添加 HMR 支持代码：

      ```javascript
      // 在入口文件的最后添加以下代码
      if (module.hot) {
        module.hot.accept((err) => {
          if (err) {
            console.error("Cannot apply HMR update.", err);
          }
        });
      }
      ```

      > 使用 webpack-dev-server 的 cli 功能只需要在命令行中添加--hot，webpack-dev-server 会自动将 webpack.HotModuleReplacementPlugin 这个插件添加到 webpack 的配置中去，因此开启 HotModuleReplacementPlugin 的最简单方式就是通过命令行使用--hot --inline

5. proxy

   在实际开发中，本地开发服务器是不能直接请求线上数据接口的，这是因为浏览器的同源安全策略导致的跨域问题，这时候可以使用 devServer.proxy 来解决本地开发跨域问题。

   下面举几种常见的使用方式：

   - 将页面访问的/api 所有请求转发到 baidu.com 上：

     ```javascript
     // webpack.config.js
     module.exports = {
       // ...
       devServer: {
         proxy: {
           "/api": "http://baidu.com",
         },
       },
       // ...
     };
     ```

     此时，假如我们请求/api/users 则会被转发到<http://baidu.com/api/users>线上地址

   - 将/api/users 请求转发到<http://baidu.com/users>：

     ```javascript
     // webpack.config.js
     module.exports = {
       // ...
       devServer: {
         proxy: {
           "/api": {
             target: "http://baidu.com",
             pathRewrite: {
               "^/api": "",
             },
           },
         },
       },
       // ...
     };
     ```

   - 另外，如果要转发的网址是支持 https 的，则需要配置 secure=false 来防止转发失败：

     ```javascript
     // webpack.config.js
     module.exports = {
       // ...
       devServer: {
         proxy: {
           "/api": {
             target: "https://baidu.com",
             secure: false,
           },
         },
       },
       // ...
     };
     ```

   - 如果特定类型的接口数据不需要转发，可以使用 bypass 来实现：

     ```javascript
     // webpack.config.js
     module.exports = {
       // ...
       devServer: {
         proxy: {
           "/api": {
             target: "http://baidu.com",
             bypass(req, res, proxyOptions) {
               // 判断请求头中accept的值
               if (req.headers.accept.indexOf("html") !== -1) {
                 // 如果请求的是html文件，则跳过代理，返回指定的文件
                 console.log("Skipping proxy for HTML request!");
                 return "/index.html";
               }
             },
           },
         },
       },
       // ...
     };
     ```

   - 也可以指定需要代理的地址，其他地址都放行：

     ```javascript
     // webpack.config.js
     module.exports = {
       // ...
       devServer: {
         proxy: {
           "/api": {
             target: "http://baidu.com",
             // 只代理/auth和/api两个地址的请求
             context: ["/auth", "/api"],
           },
         },
       },
       // ...
     };
     ```

6. 自定义中间件：

   在 webpack-dev-server 中有两个时机可以插入自定义中间件，分别是 devServer.before 和 devServer.after，即 webpack-dev-server 加载所有内部中间件之前和之后。

   自定义中间件的一个常见应用是实现 mock server，即在前后端分离开发的时候，依据前后端接口的约定格式提供假数据，以实现前后端同时并行开发，前端不需要等待后端开发完成。

   下面是一个示例，在 devServer.before 插入一个接口/api/mock.json，启动 dev server 后，访问<http://localhost:9000/api/mock.json>就可以得到伪造的假数据：

   ```javascript
   // webpack.config.js
   module.exports = {
     // ...
     devServer: {
       port: 9000,
       before(app, server) {
         app.get("/api/mock.json", (req, res) => {
           res.json({
             hello: "world",
           });
         });
       },
     },
     // ...
   };
   ```

7. devServer.compress

   服务开启 Gzip 压缩。

8. webpack-dev-server 常用配置总结

   - devServer.historyApiFallback

     配置如果找不到页面就显示默认显示的页面

   - devServer.compress

     启用 Gzip 压缩

   - devServer.hotOnly

     构建失败的时候是否不允许退回到使用刷新网页

   - devServer.inline

     模式切换，默认为内联模式，使用 false 切换到 iframe 模式

   - devServer.open

     启动后是否自动使用浏览器打开首页

   - devServer.openPage

     启动后自动使用浏览器打开设置的页面

   - devServer.overlay

     是否允许使用全屏覆盖的方式显示编译错误，默认不允许

   - devServer.port

     监听端口号，默认 8080

   - devServer.host

     指定 host，使用 0.0.0.0 可以让局域网内可以访问

   - devServer.contentBase

     告诉服务器从哪里提供内容，只有在想要提供静态文件时才需要

   - devServer.publicPath

     设置内存中的打包文件的虚拟路径映射，区别于 output.publicPath

   - devServer.staticOptions

     为 ExpressJS 的 express.static 配置参数

   - devServer.clientLogLevel

     在 inline 模式下用于控制在浏览器中打印的 log 级别，如 error、warning、info 和 none

   - devServer.quiet

     静默模式，设置为 true 则不在控制台输出 log

   - devServer.noInfo

     不输出启动 log

   - devServer.lazy

     不监听文件变化，而是当请求来的时候再重新编译

   - devServer.watchOptions

     watch 相关配置，可以用于控制间隔多少时间检测文件的变化

   - devServer.headers

     自定义请求头，例如自定义 userAgent 等

   - devServer.https

     https 需要的证书签名等配置

#### 2-3-8-Webpack-环境相关配置与配置文件拆分

实际开发中，为了方便开发调试和上线，一般会为开发环境和生产环境提供不同的 webpack 配置文件

1. 开发环境和生产环境的主要区别

   - 生产环境往往需要分离 css 成单独文件，以便多个页面共享同一个 css 文件
   - 生产环境需要压缩 HTML/CSS/JS
   - 生产环境需要压缩图片
   - 开发环境需要生成 SourceMap 文件方便调试
   - 开发环境需要打印 debug 的信息
   - 开发环境需要 HMR、devServer 等功能

2. webpack 配置文件常用划分方式

   - webpack.config.js

     所有环境的默认入口配置文件

   - webpack.base.js

     基础部分，即多个文件中共享的配置

   - webpack.development.js

     开发环境使用的配置

   - webpack.production.js

     生产环境使用的配置

   存在多个配置文件时，可以使用 webpack-merge 进行配置文件的合并，例如：

   ```javascript
   // webpack.config.js
   const baseWebpackConfig = require("./webpack.base.js");
   const devWebpackConfig = require("./webpack.development.js");
   const merge = require("webpack-merge");
   module.exports = merge(baseWebpackConfig, devWebpackConfig);
   ```

3. 判断 webpack 使用环境

   - 使用 cross-env 和 NODE_ENV

     首先安装依赖包：

     ```bash
     npm i cross-env -D
     ```

     然后修改 npm scripts 内容：

     ```json
     // package.json
     {
       // ...
       "scripts": {
         "build": "cross-env NODE_ENV=production webpack --config webpack.config.js"
       }
       // ...
     }
     ```

     也可以在 webpack 配置文件中使用环境变量以针对不同环境进行区别配置：

     ```javascript
     // webpack.base.js
     const isProduction = process.env.NODE_ENV === "production";
     module.exports = {
       // ...
       devtool: isProduction ? null : "source-map",
       // ...
     };
     ```

   - 使用 function 配置

     webpack 的配置除了是对象，还可以是函数，如果是函数则接受一个 mode 参数，即当前环境变量，因此可以使用类似以下的方式进行配置：

     ```json
     // package.json
     {
       // ...
       "scripts": {
         "build": "webpack --mode production --config webpack.config.js"
       }
       // ...
     }
     ```

     ```javascript
     // webpack.config.js
     module.exports = (mode) => {
       if (mode === "production") {
         // 生产环境配置
       } else {
         // 开发环境配置
       }
     };
     ```

## 3-Webpack-优化

### 3-1-体积优化

#### 3-1-1-JavaScript

##### 3-1-1-1-压缩

在 mode=production 下，webpack 会自动压缩代码，我们可以自定义自己的压缩工具，推荐使用 terser-webpack-plugin，使用方式如下示例：

```javascript
// webpack.config.js
const TerserWebpackPlugin = require("terser-webpack-plugin");
module.exports = {
  // ...
  optimization: {
    minimizer: [
      new TerserWebpackPlugin({
        cache: true, // 使用cache加快二次构建速度
        parallel: true, // 开启多线程，加快构建压缩速度
        terserOptions: {
          comments: false, // 去除注释
          compress: {
            unused: true, // 删除未使用的变量、函数等
            drop_debugger: true, // 删除debugger
            drop_console: true, // 删除console
            dead_code: true, // 删除无用的代码
          },
        },
      }),
    ],
  },
  // ...
};
```

##### 3-1-1-2-Scope-Hoisting

作用域提升(Scope Hoisting)是指 webpack 通过 ES6 语法的静态分析，分析出模块之间的依赖关系，尽可能的把模块放到同一个函数中，这样打包出来的文件更小、运行更快，可以通过配置 optimization.concatenateModules=true 来开启：

```javascript
// webpack.config.js
module.exports = {
  // ...
  optimization: {
    concatenateModules: true,
  },
  // ...
};
```

##### 3-1-1-3-其他代码级别优化技巧

- 合理划分代码职责，适当使用按需加载
- 使用 webpack-bundle-analyzer 插件帮助分析 webpack 打包后的模块依赖关系
- 设置合理的 SplitChunks 分组
- 对于一些 UI 组件库，如 AntDesign、ElementUI 等，可以使用 babel-plugin-import 工具进行优化
- 使用 lodash、momentjs 这类库，不要一股脑全部引入，要按需引入，momentjs 可以使用 date-fns 库代替
- 合理使用 hash 占位符，防止 hash 重复出现导致文件名变化从而 http 缓存过期
- 合理使用 polyfill，防止多余的代码
- 使用 ES6 语法，尽量不要使用具有副作用的代码以加强 Tree-Shaking 的效果
- 使用 webpack 的 Scope Hoisting 功能

#### 3-1-2-CSS

##### 3-1-2-1-CSS-导出

CSS 文件应该导出到单独的 CSS 文件中而不要直接打包进 JS 文件，可以使用 mini-css-extract-plugin 插件：

```javascript
// webpack.config.js
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
            options: {
              // 在这里配置插件详细功能
            },
          },
          {
            loader: "css-loader",
          },
        ],
      },
    ],
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: "[name].css",
      chunkFilename: "[name].[contenthash:8].css",
    }),
  ],
  // ...
};
```

> css 中推荐使用[contenthash]占位符做文件的 hash 算法

##### 3-1-2-2-压缩

css 代码压缩推荐使用 cssnano，这是一款基于 postcss 的功能强大的插件包，集成了 30 多个插件。在 webpack 中，css-loader 已经集成了 cssnano，我们还可以使用 optimize-css-assets-webpack-plugin 来自定义 cssnano 规则，例如：

```javascript
// webpack.config.js
const OptimizeCssAssetsWebpackPlugin = require("optimize-css-assets-webpack-plugin");
module.exports = {
  // ...
  plugins: [
    new OptimizeCssAssetsWebpackPlugin({
      assetNameRegExp: /\.optimize\.css$/g,
      cssProcessor: require("cssnano"), // 这里指定压缩引擎，默认就是使用cssnano
      cssProcessorPluginOptions: {
        // 对cssnano规则进行配置
        preset: ["default", { discardComments: { removeAll: true } }],
      },
      canPrint: true,
    }),
  ],
  // ...
};
```

> optimize-css-assets-webpack-plugin 插件的默认配置基本上可以满足日常开发，不需要额外配置就能达到最佳效果

#### 3-1-3-图片资源优化

通常我们的代码体积会比图片体积小很多，有的时候整个页面的代码都不如一张图片大，因此优化图片资源非常重要。常用的方式有：

- 使用 url-loader，指定 limit 来将小于指定大小的图片编码成 Base64 格式嵌入文件中，减少 http 请求
- 使用 svg-url-loader，和 url-loader 类似，只不过使用 URL encoding 编码处理 SVG 图片，因为 SVG 图片是纯文本格式
- 使用雪碧图(CSS Sprite)处理小图标，节省 http 请求
- 使用 image-webpack-plugin 压缩大图片，该插件支持 jpg、png、gif、svg 格式的图片

### 3-2-增强缓存命中率

web 开发中，应该充分利用 http 协议和浏览器缓存来做好页面代码的持久化缓存，通过合理配置 webpack，可以更好的提升应用持久化缓存策略，通过将资源缓存到客户端，避免之后每次都重新下载。

#### 3-2-1-浏览器缓存策略和-Webpack-缓存配置

使用浏览器的持久化缓存方案一般分两步：

1. 动静分离

   将静态资源(JavaScript、CSS、图片字体文件等)这些不经常变更的文件放到单独的服务器，与动态页面分开部署，方便维护，常见的方案是放到 CDN 服务器，因为可以更接近用户终端，提供加速服务，而且静态资源不具有动态逻辑，单独的域名可以减少页面请求中的 cookie 等不必要字段，减少 http 请求。

   > 单独部署静态资源后，应该配置合理的 http 缓存协议，比如使用 Cache-Control 设置 max-age 来告诉浏览器缓存文件的有效期限

2. 重命名变更的静态资源

   对发生变更的静态资源重命名，这样静态文件虽然使用了 CDN 和强缓存，但是文件路径(网址)发生了变换，浏览器就会重新请求下载

   > webpack 构建项目时，也可以对发生变更的文件自动更新，通过更新 hash 值：
   >
   > - hash：每次编译 Compilation 对象的 hash，全局一致，跟单次编译相关，更单个文件无关，不推荐使用
   > - chunkhash：chunk 的 hash，根据不同的 chunk 及其包含的模块计算出来，chunk 中包含的任意模块发生变化都会引起 chunkhash 变化，推荐使用
   > - contenthash：CSS 文件特有的 hash，根据 CSS 文件内容计算出来，CSS 发生变化则 contenthash 变化，推荐 CSS 导出中使用
   >
   > webpack 中 hash 值的使用是通过占位符语法，类似 bundle.[chunkhash:8].js

   对于 Webpack 打包出来的资源，还可以通过 webpack-manifest-plugin 插件生成一个用于类似 Application Cache 或者 PWA 方案的 JSON 文件，里面包含了源文件名和带哈希文件名的映射，在服务器端通过这个 JSON 文件就可以方便的找到我们真正要执行的文件。

#### 3-2-2-提取依赖和-Runtime-到单独文件

在实际开发中，依赖总是比业务员逻辑变更频率低，比如在项目中使用 JS 库 Vue、React 甚至 jQuery，将变更频率低的依赖模块提取到单独的文件中，这样浏览器就可以独立缓存它们，这样即使应用中的代码发生变更，也不会再重新下载依赖。webpack 中将依赖项提取到独立的 chunk 中，需要执行以下三步：

1. 将输出文件名替换为类似[name].[chunkname].js
2. 对应于上一步，要把 entry 的值改为对象，而不是直接使用字符串或数组，这样 entry 中的键名(chunk 的名称)就会在打包时自动被第一步的[name]所替代
3. 最后一步就是通过合理的设置 optimization.splitChunks 来划分不同的代码

#### 3-2-3-Webpack-的-Runtime

Webpack 打包时，除了模块代码之外，Webpack 的 bundle 中还包含了 Runtime（运行时），这部分代码是一小段用来管理模块执行和加载的代码。当我们将代码拆分成多个文件时，这小部分代码在 chunk id 和匹配的文件之间会生成一个映射表，Webpack 将 Runtime 包含在了最新生成的 chunk 中，这个 chunk 就是我们代码中的 optimization.splitChunks 拆分出来的一部分。每次 chunk 有任何变更，这一小部分代码也会随之更改，同时也会导致整个 chunk 发生改变。

为了解决这个问题，我们可以将 runtime 移动到一个独立的文件中。在 Webpack 中，可以通过开启 optimization.runtimeChunk 选项来实现：

```javascript
// webpack.config.js
module.exports = {
  // ...
  optimization: {
    runtimeChunk: true,
  },
  // ...
};
```

通过上面的配置，我们打包之后，多出来一个 runtime 命名的文件，这个就是 Webpack 的 Runtime 代码，这段代码比较精短，所以为了达到更好的体验，我们可以尝试把 Webpack 的 Runtime 代码内联到 HTML 中。Runtime 的代码不多，内联到 HTML 中可以帮助我们节省 HTTP 请求（在 HTTP/1 中尤为重要；在 HTTP/2 中虽然没那么重要，但仍然能起到一定作用）。想要内联 Runtime 代码到 HTML 页面中，需要使用一个 html-webpack-inline-source-plugin，这个插件实际为 html-webpack-plugin 的插件，所以需要和 html-webpack-plugin 一起使用，详细的配置如下：

```javascript
// webpack.config.js
const HtmlWebpackPlugin = require("html-webpack-plugin");
const InlineSourcePlugin = require("html-webpack-inline-source-plugin");

module.exports = {
  // ...
  plugins: [
    new HtmlWebpackPlugin({
      // 需要内联的文件名正则，runtime的正则是包含runtime关键字
      inlineSource: "runtime~.+.js",
    }),
    // 注意顺序，这个插件要配置在html-webpack-plugin之后
    new InlineSourcePlugin(),
  ],
};
```

> _Tips_：在 Webpack 4.29.6 版本后修改了模板输出的 Template，即使 entry 变化，实际 Runtime 部分的内容也不会改变，所以以上分离 Runtime 的方案适用于低版本的 Webpack

#### 3-2-4-合理使用动态加载功能拆分代码

动态加载代码，指的是通过 import()或合理的使用动态加载功能拆分代码是很重要的优化手段，当然前提是合理！

#### 3-2-5-多页面项目按照路由拆分代码

如果我们的项目是一个由多个路由或页面组成的，但是代码中只有一个单独的 JavaScript 文件（一个单独的入口 chunk），这样会导致不管访问任何页面都会加载整站资源，让用户付出额外的流量。此外，如果这个用户经常只是访问其中的某个页面，但是当我们更改了其它页面的代码，Webpack 将会重新编译，那么整个 bundle 的文件名哈希值就会发生变化，最终导致用户重新下载整个网站的代码，造成不必要的浪费。

这时候合理的做法是将整个项目利用多页面打包方案进行划分，我们将代码按照页面进行拆分，这样用户访问某个页面的时候，实际下载的只是当前页面的代码，而不是整个网站的代码，浏览器也更好的缓存了这部分代码，当其他页面代码发生变化的时候，当前代码的哈希值不会失效，自然用户不会重复下载相同的代码了。

对于 Vue、React 这类多路由页面，可以通过 import()的方式来动态加载模块。

### 3-3-抽取公共代码

Webpack 中有三种方式来实现代码拆分(Code Splitting)：

1. entry 配置：通过多个 entry 文件来实现
2. 动态加载(按需加载)：通过在代码中使用 import()或者 require.ensure 来动态加载
3. 抽取公共代码：使用 splitChunks 配置来抽取公共代码

要讲解抽取公共代码，先要清楚 webpack 中的三个重要概念：

- module：就是 JavaScript 的模块，简单说来就是通过 import、require 语句引入的代码，在 webpack 中不仅是 js 文件，还包括 css、图片等资源
- chunk：是 webpack 根据功能拆分出来的，包含 module，可能是一对一，也可能是一对多，chunk 包含三种情况，就是上面所说的三种实现代码拆分的情况
- bundle：是 webpack 打包之后的各个文件，一般就是和 chunk 一一对应的，bundle 就是对 chunk 进行编译压缩打包处理后的产出

#### 3-3-1-splitChunks-默认配置

splitChunks 的默认规则如下：

```javascript
// webpack.config.js
module.exports = {
  // ...
  optimization: {
    splitChunks: {
      chunks: "async", // 提取chunks的方式，有三种取值：initial|all|async
      minSize: 30000, // 拆分出来的chunk的最小尺寸，在development下是10000，这个值越大那么拆分出来的单个chunk文件越大，拆分出来的chunk文件数量就会越少，当这个值很大的时候，就不会做公共部分代码提取了
      maxSize: 0, // 意义同上，这是最大尺寸，0为不限制，优先级：minSize>maxSize>maxAsyncRequests/maxInitialRequest
      minChunks: 1, // 被提取的模块至少要在几个chunk中被引用，这个值越大，抽取出来的文件越小
      maxAsyncRequests: 5, // 在做一次按需加载的时候最多有多少个异步请求，为1的时候就不会提取公共chunk了
      maxInitialRequests: 3, // 针对一个entry做初始化模块拆分的时候的最大文件数，优先级高于cacheGroup，所以为1的时候就不会抽取initial common了
      automaticNameDelimiter: "~", // 打包文件名分隔符
      name: true, // 拆分出来文件的名字，默认为true表示自动生成文件名，如果设置为固定的字符串，那么所有的chunk都会被合并成一个文件
      cacheGroups: {
        default: {
          minChunks: 2,
          priority: -20, // 缓存组优先级，当一个模块可能属于多个chunkGroup时，使用该处设定的优先级
          reuseExistingChunk: true, // 如果该chunk包含的modules都已经在另一个被抽取出来的chunk中存在，那么直接引用已存在的chunk，不会再重新产生
        },
        vendors: {
          test: /[\\/]node_modules[\\/]/, // 正则规则，如果符合就提取chunk
          priority: -10, // 缓存组优先级
        },
      },
    },
  },
  // ...
};
```

splitChunks 的默认配置对应的就是 chunk 生成的第二种情况，即通过写代码时主动使用 import()或 require.ensure()来动态加载。

#### 3-3-2-chunks

splitChunks.chunks 有三种取值，其产生结果可以概括为：

- chunks:async

  这是默认的取值，该取值模式下，只有动态引入的代码会被拆分

- chunks:initial

  该取值模式下，动态引入的模块仍然会被拆分，同时，对于同步引入的代码，如果有多出都在使用，则拆分出来公用，至于共同引用多少次才会被拆分，取决于 minChunks 的取值

- chunks:all

  该取值模式下，将会最大程度的生成复用代码，复用代码在 http cache 环境下，多页应用由一个页面跳转到另外一个公用代码的页面时，可以节省 http 请求，因此一般说来该取值模式是最推荐的

#### 3-2-3-cacheGroups

cacheGroups(缓存组)是 splitChunks 的核心配置，默认的 cacheGroup 有两个：default 和 vendors。如果将两个默认分组都设置为 false，那么 splitChunks 将不会起作用。

cacheGroups 除了拥有默认配置的所有配置项目(如 minSize、minChunks、name 等等)，还拥有三个独特的配置项：test、priority 和 reuseExistingChunk。**cacheGroups 必须同时满足各个配置项的条件才会生效**。

- reuseExistingChunk：是否使用已有的 chunk，为 true 则如果当前将要生成的 chunk 包含的模块已经被抽取过的时候，那么不再重新生成 。

- priority：权重，就是当一个模块同时满足多个缓存组的条件时，按什么优先级去使用处理规则。

- test：当满足条件时才会命中该缓存组，取值可以是正则、字符串和函数。如果是函数，则要求返回值为 true/false，该函数接收两个参数：

  - module：每个模块打包的时候，都会执行 test 函数，并且传入模块 module 对象，该对象包含模块的基本信息，例如类型、路径和文件 hash 等

  - chunks：当前模块被分到哪些 chunks 使用，module 跟 chunks 关系可能是一对一，也可能是多对一，所以一旦我们使用 chunks 做匹配，那么符合条件的 chunk 内包含的模块都会被匹配到

    因为 splitChunks 不仅作用于 JavaScript，也可以作用于 CSS，所以使用类似 test:/[\\/]node_modules[\\/]的写法，实际也会匹配出 node_modules 中的 CSS，如果我们用到的一个 npm 包引入了自己的 css 文件，那么也会命中拆分逻辑。如果此时想要排除这部分 CSS 文件，或者对 CSS 文件设置单独的处理规则，就可以使用 test 函数，或者设置不同 priority 的 cacheGroup，利用 test 函数还可以实现如忽略特定文件等更细化的匹配。

### 3-4-构建速度优化

webpack 中影响构建速度的主要因素有两个：一是 loader 和 plugin 方面的构建过程，一是压缩。

> 新版的 webpack 4 要比低版本的 webpack 3 和 2 快很多，所以单纯升级 webpack 就可以提升一大截构建速度
>
> 区分开发和生产环境，使用不同的配置各司其职，例如在开发阶段，代码压缩、目录清理、计算 hash 和提取 CSS 这些都没必要做
>
> 耗时排查可以使用插件：speed-measure-webpack-plugin

#### 3-4-1-优化构建过程

##### 3-4-1-1-减少查找过程

1. 使用 resolve.alias 减少查找过程

   resolve.alias 配置项通过别名(alias)来把原导入路径映射成一个新的导入路径比如我们经常使用的 react 库，其实 react 库中有两套代码，一套是基于 CommonJs 的模块化代码，一套是打包好的完整代码，react.js 用于开发环境，react.min.js 用于生产环境。所以通过 resolve.alias 配置，可以让 Webpack 处理时，直接使用打包好的 react，从而跳过耗时的模块解析，还有我们项目中可能会有一些相对路径的写法，可以使用 alias 配置来减少查找过程。

2. 使用 resolve.extensions 优先查找

   在导入语句没带文件后缀时，Webpack 会自动带上后缀后去尝试询问文件是否存在，查询的顺序是按照我们配置的 resolve.extensions 顺序从前到后查找，所以我们应该把常用到的文件后缀写在前面，或者我们导入模块时，尽量带上文件后缀名。

3. 使用 module.noParse 排除不需要解析的模块

   module.noParse 配置项可以让 Webpack 忽略对部分没采用模块化的文件递归解析处理，例如：jQuery、ChartJS，它们体积庞大又没有采用模块化标准，让 Webpack 去解析这些文件耗时又没有意义，所以使用 module.noParse 排除它们。

   > 被忽略的文件里不应该包含 import、require、define 等模块化语句，否则会导致构建出的代码中包含无法在浏览器环境下执行的模块化语句

4. 合理配置 rule 的查找范围

   在 rule 配置上，有 test、include、exclude 三个可以控制范围的配置，最佳实践是:

   1. 只在 test 和文件名匹配中使用正则表达式
   2. 在 include 和 exclude 中使用绝对路径数组
   3. 尽量避免 exclude，更倾向于使用 include

   > exclude 的优先级要高于 include 和 test，因此当三者配置有冲突时，exclude 会优先于其他两个配置

##### 3-4-1-2-利用多线程提升构建速度

让 webpack 支持多个线程进行同时打包，可以提高编译打包的速度，但是对于比较简单的项目，使用多线程编译打包反而会因为多线程打包浪费更多的 CPU 资源，这样不仅不能加快打包速度，反而会降低打包速度。

webpack 多线程打包主要有两种解决方案：thread-loader 和 HappyPack。

1. thread-loader

   thread-loader 是针对 loader 进行优化的，它会将 loader 放置在一个 worker 池里面运行，以达到多线程构建。thread-loader 在使用的时候，需要将其放置在其他 loader 之前，如下所示：

   ```javascript
   // webpack.config.js
   module.exports = {
     // ...
     module: {
       rules: [
         {
           test: /\.js$/,
           include: path.resolve("src"),
           use: [
             {
               loader: "thread-loader",
             },
             // 其他高开销的loader放在后面，比如babel-loader
           ],
         },
       ],
     },
     // ...
   };
   ```

2. HappyPack

   HappyPack 是通过多进程模型，来加速代码构建，但是给 loader 配置使用 HappyPack 需要对应的 loader 支持才行，例如 url-loader 和 file-loader 就不支持 HappyPack。

##### 3-4-1-3-预先编译

预先编译和打包不会变动存在的文件，在业务代码中直接引入，可以加快 Webpack 编译打包的速度，比如代码中引入的第三方库，这些库在实际开发中并不会升级版本或修改其内部代码，但是在每次构建时，还是会被重新编译和打包，这样就很浪费时间，而使用 webpack.DllPlugin 就可以解决这个问题，使用它可以在第一次编译打包后生成一份不变的代码共其他模块引用，这样下一次构建的时候就可以节省编译打包的时间。

要使用 DllPlugin 的功能，需要配合 webpack.DllReferencePlugin 来使用。DLLPlugin 这个插件是在一个额外独立的 Webpack 设置中创建一个只有公共库的 dll 文件，这时候我们项目中应该单独为 dll 文件创建一个配置文件，例如 webpack.config.dll.js，之后使用该配置文件打包会将所有列出的第三方库依赖打包到一个 dll 文件，同时还会生成一个 manifest.json 文件，其中包含了第三方库和打包出来的 dll 文件的映射关系，而 DllReferencePlugin 就是在使用正常配置文件打包时，读取 manifest.json 中的映射信息。

当第一次使用 webpack.config.dll.js 打包时，会对列出的所有第三方库进行打包，之后就不会再打包它们了。而每次运行 webpack.config.js 打包时，就只会打包项目中本身的代码，当需要引入第三方库时，就通过 DllReferencePlugin 从 dll 中读取第三方依赖库，只有当第三方公共库的内部代码发生变化时，才会需要再次执行 webpack.config.dll.js 来打包。

> DLL 是动态链接库（Dynamic-link library）的英文缩写，最早是微软提出来的一种共享函数库概念，实际就是将一些经常会共享的代码制作成 DLL 文档，当其他代码需要使用这些 DLL 中的代码时，Windows 操作系统会将 DLL 文档加载到内存中。这里借用了 DLL 的概念，帮助 Webpack 使用者理解用途

下面是一个配置示例，假设需要用到的第三方依赖库有 react 和 react-dom：

```javascript
// webpack.config.dll.js
const webpack = require("webpack");
// 这里列出第三方依赖库
const vendors = ["react", "react-dom"];
module.exports = {
  mode: "production",
  entry: {
    // 定义程序中打包公共文件的入口文件vendor.js
    vendor: vendors,
  },
  output: {
    filename: "[name].[chunkhash].js",
    // 这里是使用将vendor作为library导出，并且指定全局变量名字是[name]_[chunkhash]
    library: "[name]_[chunkhash]",
  },
  plugins: [
    new webpack.DllPlugin({
      // 这里设置manifest.json路径
      path: "manifest.json",
      name: "[name]_[chunkhash]",
      context: __dirname,
    }),
  ],
};
```

然后使用 webpack.config.dll.js 打包就会产出一个名为 vendor.xxxxx.js 的 dll 文件，以及一个 manifest.json 文件。

接下来再配置正常的 webpack 配置文件：

```javascript
// webpack.config.js
const webpack = require("webpack");
module.exports = {
  entry: {
    app: "./src/index.js",
  },
  output: {
    filename: "[name].[chunkhash].js",
  },
  plugins: [
    new webpack.DllReferencePlugin({
      context: __dirname,
      // 这里导入manifest.json文件
      manifest: require("./manifest.json"),
    }),
  ],
};
```

这时候再使用 webpack.config.js 打包，得到的 app.js 文件中并不包含 webpack.config.dll.js 打包出来的 dll 的内容，打包速度得到提升。

> 在实际操作中，HTML 中不会主动引入 dll 的 vendor.js 文件，这时候需要我们想办法手动或者通过插件添加进去，比如使用 add-asset-html-webpack-plugin，或者在 dll 打包的时候就修改一下 html-webpack-plugin 的 template 文件，正常打包的时候直接使用这个 template 文件再打包一次即可

##### 3-4-1-4-缓存

提升构建速度的一个重要方法是使用缓存，下面介绍常用的两种缓存方式：

1. babel-loader 配置

   Webpack 中打包的核心是 JavaScript 文件的打包，JavaScript 使用的是 babel-loader，其实打包时间长很多时候是 babel-loader 执行慢导致的。这时候我们不仅要使用 exclude 和 include 来尽可能准确的指定要转换内容的范畴，还需要关注 babel-loader 在执行的时候，可能会产生一些运行期间重复的公共文件，造成代码体积大冗余，同时也会减慢编译的速度。

   babel-loader 提供了 cacheDirectory 配置给 Babel 编译时给定的目录，并且将用于缓存加载器的结果，但是这个设置默认是 false 关闭的状态，我们需要设置为 true，这样 babel-loader 将使用默认的缓存目录：node_modules/.cache/babel-loader，如果在任何根目录下都没有找到 node_modules 目录，将会降级回退到操作系统默认的临时文件目录。

2. 其他构建过程的优化

   1. sourceMap 生成耗时严重，因该根据需求对 devtool 设置合适的值
   2. 切换一些 loader 或者插件，比如：fast-sass-loader 可以并行处理 sass 文件，要比 sass-loader 快 5~10 倍

#### 3-4-2-优化压缩速度

压缩只在生产环境打包才会做，而且对于压缩，除了添加 cache 和开启多线程支持之外，可以优化的空间很小。常见的做法是通过配置 terser-webpack-plugin 开启多线程和缓存，如下所示：

```javascript
// webpack.config.js
const TerserWebpackPlugin = require("terser-webpack-plugin");
module.exports = {
  // ...
  optimization: {
    minimizer: [
      new TerserWebpackPlugin({
        cache: true, // 开启缓存
        parallel: true, // 开启多线程支持
      }),
    ],
  },
  // ...
};
```

### 3-5-Tree-Shaking

Tree-Shaking 的本质是消除无用代码。无用代码消除，或者称为 DCE(Dead Code Elimination)广泛存在于传统编程语言编译器中，编译器判断出某些代码根本不影响输出，然后消除这部分代码，而 Tree-Shaking 是 DCE 的一种新的实现。

随着移动时代的来临，Tree-Shaking 越来越重要，因为由于网络带宽限制，传输、加载的 JS 文件体积越小，整体解析执行时间更短，用户体验则更好。

传统 DCE 主要消灭不可能执行的代码：

- 程序中不可能进入的分支、return 之后的语句
- 导致 dead variable 的代码，写入变量后不再读取的代码

和传统 DCE 不同，Tree-Shaking 更关注于消除没有用到的代码。Webpack 是基于 ES6 Modules 静态语法解析的工具，ES6 Modules 的声明保证了依赖关系是提前确定的，使得静态分析成为可能，这样 webpack 中代码不需要执行就可以知道是否被使用，从而能够实现 Tree-Shaking。

ES6 Modules 的特点主要有：

- import 和 export 是显性声明的
- import 的模块名只能是字符串常量
- 模块的依赖关系是可以根据 import 引用关系推到出来的
- 模块的依赖关系与运行时状态无关

webpack 中，Tree-Shaking 要配合 mode=production 来使用，因为 webpack 的 Tree-Shaking 实际分了两步来实现：

1. webpack 自己分析 ES6 Modules 的引入和使用情况，去除不使用的 import 引入
2. 借助工具(如 terser-webpack-plugin)进行删除，这些工具只在 mode=production 中会被使用

对于有副作用的代码(例如函数内部调用了外部方法、函数内部直接使用全局变量以及直接修改原型等)，因为 webpack 不知道代码内部究竟做了什么事情，因此不会被 Tree-Shaking。

> 纯函数：对于相同的输入总是产生相同的输出，并且不依赖外部环境，也不改变外部环境。不纯即使具有副作用。

要解决 webpack 中 Tree-Shaking 不能作用于有副作用代码的问题，有两种方法：

1. 在代码中主动消除副作用
2. 配置 sideEffects 告诉 webpack，模块是安全的，不会带有副作用：

   在 package.json 中设置 sideEffects 指定哪些文件中的代码具有副作用，从而对没有副作用的文件代码可以放心使用 Tree-Shaking 进行优化；也可以设置 sideEffects 为 false 来指出项目下所有文件代码都不必考虑副作用，可以使用 Tree-Shaking 来进行优化

要真正发挥 Tree-Shaking 的强大作用，需要注意以下几点：

1. 要使用 Tree-Shaking 必然要保证引用的模块都是 ES6 规范的，很多工具库或者类库都提供了 ES6 语法的库，例如 lodash 的 ES6 版本是 lodash-es
2. 按需引入模块，避免「一把梭」
3. 减少代码中的副作用代码

## 4-Webpack-工程化最佳实践

### 4-1-NPM-Scripts

使用 NPM Scripts 来配置开发命令，即 package.json 的 scripts 字段，这样即使我们修改脚本甚至切换 webpack 到其他构建工具，对于团队其他成员来说，使用的命令还是不变的。

建议的命令包括：

1. npm start：相当于 npm run start，用于开发命令，快速启动本地开发服务
2. npm run build：用于生产环境打包
3. 其他命令，例如 npm run test/npm run lint 等，对应相关需求

> 可以使用 cross-env 来区分环境

示例如下：

```json
// package.json
{
  // ...
  "scripts": {
    "start": "cross-env NODE_ENV=development webpack --config webpack.config.dev.js --mode development",
    "build": "cross-env NODE_ENV=production webpack --config webpack.config.prod.js --mode production",
    "lint": "lint-staged",
    "analyzer": "cross-env NODE_ENV=production webpack --config webpack.config.analyzer.js --mode production"
  }
  // ...
}
```

### 4-2-区分多环境配置

区分生产环境和开发环境配置，并且封装通用配置:

1. 通用配置 webpack.config.base.js
2. 开发环境配置 webpack.config.dev.js
3. 生产环境配置 webpack.config.prod.js

#### 4-2-1-通用配置

通用配置一般配置 loader、plugin 和 entry 等通用的配置项，但是有些需要根据 cross-env 传入的 NODE_ENV 环境变量进行相关的配置，例如当 NODE_ENV==='development'的时候使用 style-loader 将 CSS 文件插入 HTML 中，而当 NODE_ENV==='production'时则使用 mini-css-extract-plugin 将 CSS 文件单独分离出来。

#### 4-2-2-开发配置

开发配置主要用于开发环境，主要配置 devServer、API Mock 等，这部分配置注重的是效率，因此打包速度优化也很重要

#### 4-2-3-生成配置

生产环境配置注重的是线上最优打包配置，包括 splitChunks、压缩资源、CDN 路径配置(output.publicPath)等，还可以在 terser-webpack-plugin 中配置强制去除一些忘记删除的调试信息(比如 debugger、alert、console 等)

> _Tips_：生产环境打包不建议生成 sourcemap，如果生成了也不要上传到线上环境，因为如果 sourcemap 上线之后，等于别人就可以通过 Chrome 等工具直接查看线上代码的源码，这是十分危险的！

#### 4-2-4-打包分析配置

除了上面三个常规配置外，可以再增加一个 webpack.config.analyzer.js 来分析打包是否合理，这个配置实际上是继承 webpack.config.prod.js，然后增加 webpack-bundle-analyzer 插件配置

#### 4-2-5-配置文件管理

webpack 配置文件拆分之后，各自之间都有依赖关系，具体如下：

1. webpack.config.dev.js 是合并了 webpack.config.base.js 和自己的配置
2. webpack.config.prod.js 合并了 webpack.config.base.js 和自己的配置
3. webpack.config.analyzer.js 合并了 webpack.config.prod.js 和自己的配置，而 webpack.config.prod.js 又是来自于 webpack.config.base.js

要维护这个配置关系，那么就需要使用 webpack-merge 这个工具库，webpack-merge 主要是提供一个 Webpack 配置对象 Merge 函数，用来合并两个配置。

下面以 webpack.config.analyzer.js 为例：

```javascript
// webpack.config.analyzer.js
const merge = require("webpack-merge");
const prodWebpackConfig = require("./webpack.config.prod.js");
const { BundleAnalyzerPlugin } = require("webpack-bundle-analyzer");
module.exports = merge(prodWebpackConfig, {
  // 增加webpack-bundle-analyzer的配置
  plugins: [new BundleAnalyzerPlugin()],
});
```

### 4-3-合理使用-splitChunks

使用 splitChunks 主要是为了合理的划分资源大小，提高缓存命中率，从而降低资源的加载时间，在划分合理性上一定要注意把握力度，太细不能充分利用 HTTP Cache，太粗又会导致加载速度慢，一般来说可以按照下面三个原则来拆分代码：

1. 变更频次
2. 页面 Router
3. 动静分离

#### 4-3-1-变更频次

代码按照变更频次来使用 splitChunks，即首先将不经常修改的通用框架和库拆分出来放到一起作为 common 代码，然后再把业务代码按照页面间公共部分和私有部分进行拆分

#### 4-3-2-页面 Router

通过变更频次原则将通用代码拆分出来之后，剩下的业务代码可以根据不同的页面之间公共代码拆分到一起，这样可以保证访问一个页面就可以将框架代码和公共代码缓存到浏览器中，再访问第二个页面就不会增加框架代码和公共代码页面请求了

#### 4-3-3-动静分离

动静分离指的是页面内使用频次不高或者需要动态异步加载（使用 import()或者 require.ensure()）的模块代码可以单独拆分到各自的 chunks，这样保证了页面首屏展现速度，另外类似 Vue、React 这类单页应用，页面 Router 之间的代码也是可以异步加载的，整个页面第一个入口就将大框架和当前页面的代码加载进来了，等点击跳到二级页面的时候只需要动态加载对应 Router 的代码即可

### 4-4-多页应用-Entry-和-HTML-管理

首先规定项目目录结构如下：

```code
|-- package.json
|
|-- webpack.config.js
|
|-- src
|   |
|   |-- libs
|   |
|   |-- pages
|   |
|   |-- details.js
|   |
|   |-- index.js
|   |
|   |-- list.js
|
|-- template
|   |
|   |-- detail.html
|   |
|   |-- index.html
|   |
|   |-- list.html
```

> 保证 template 和 entry 是固定的目录，并且名字都是对应的

这时候我们可以写个 Node.js 代码遍历对应的路径，然后生成 webpack.config.js 的 entry 和 html-webpack-plugin 内容，(这里使用 globby 这个 NPM 模块，用于模式匹配目录文件)：

```javascript
// ./scripts/utils.js
const path = require("path");
const globby = require("globby");
const getEntry = (exports.getEntry = () => {
  // 异步方式获取所有的路径
  const paths = globby.sync("./pages/*.js", {
    cwd: path.join(__dirname, "./src"),
  });
  const rs = {};
  paths.forEach((v) => {
    // 计算filename
    const name = path.basename(v, ".js");
    let p = path.join("./src", v);
    if (!p.startsWith(".")) {
      // 转成相对地址
      p = "./" + p;
    }
    rs[name] = p;
  });
  return rs;
});
```

然后遍历 entry 对象，生成 html-webpack-plugin 数组：

```javascript
// ./scripts/utils.js
const HtmlWebpackPlugin = require("html-webpack-plugin");
exports.getHtmlWebpackPlugins = () => {
  const entries = getEntry();
  return Object.keys(entries).reduce((plugins, filename) => {
    plugins.push(
      new HtmlWebpackPlugin({
        template: entries[filename],
        filename: `${filename}.html`,
        chunks: [filename],
      })
    );
    return plugins;
  }, []);
};
```

最后，在 webpack.config.js 中直接引入上面的这个文件，然后：

```javascript
// webpack.config.js
const {getEntry,getHtmlWebpackPlugins}=require('./scripts/utils')
module.exports={
  mode:'development',
  getEntry(),
  plugins:[
    // ...
    ...getHtmlWebpackPlugins()
  ],
  // ...
}
```

### 4-5-指定-chunk-的-哈希值

在生产环境打包，一定要配置文件 filename 的 hash，推荐的 hash 配置规则如下：

- JavaScript 文件使用：[chunkhash]
- CSS 文件使用：[contenthash]
- 其他静态资源使用：[hash]，例如图片、字体等，在 url-loader 中配置[hash]

### 4-6-语法层面的最佳实践

1. 使用 ES6 Modules 语法，以保证 Tree-Shaking 起作用
2. 合理使用 Polyfill，推荐使用@babel/preset-env 的 useBuiltIns='usage'方案
3. 合理使用 Webpack 的魔法注释(Magic Comments)，比如动态加载的模块要用 webpackChunkName 进行命名，还可以对重要资源使用 webpackPrefetch 进行提前预加载
4. 框架或者类库使用合理的版本，比如：
   - Lodash 使用 lodash-es 版本，并且按模块使用
   - Momentjs 使用 date-fns 代替，并且按模块使用
   - 移动页面使用 Zepto 代替 jQuery
   - Vue、React 这类框架库根据实际情况选择合适的构建版本，以 Vue 为例，其构建版本包含浏览器版本、ESM 版本、UMD 版本、完整版本等多个版本

### 4-7-其他-Webpack-配置的最佳实践

1. 生产环境使用 mini-css-extract-plugin 导出 CSS 文件
2. 生产环境使用压缩功能，包括 JavaScript、CSS、图片、SVG 等
3. 合理配置查找路径，减少查找时间，比如设置 alias、添加项目路径、排除 node_modules 查找等
4. 在 rule 配置上，有 test、include、exclude 三个可以控制范围的配置，最佳实践是：
   - 只在 test 和文件名匹配中使用正则表达式
   - 在 include 和 exclude 中使用绝对路径数组
   - 尽量避免 exclude，更倾向于使用 include
5. icon 类图片文件太多则使用 CSS Sprite 来合并图片，防止设置 url-loader 和 svg-url-loader 的 limit 值不合理，导致 icon 文件全部都以 Base64 或 URI Encoding 方式引入 CSS 文件中，导致 CSS 文件过大

### 4-8-其他方面最佳实践

1. 规范化 Git 工作流：
   1. 使用 Git Hook，类似 Husky 这类 Git Hook 库，可以帮助我们在每次提交之前(pre-commit)自动做 lint 检查
   2. 使用 Commitizen 来规范 Git 的提交 Commit Log
2. 组件化开发，公共 UI 组件、公共函数库建设。例如可以将多个页面常用的 UI 组件抽象出来，也可以将通用的工具函数库建设起来
3. 选择一个顺手的 CSS 预处理器语言，Sass、Less、Stylus，只要顺手都可以
4. 指定规则约定，包括代码规范、目录结构、文档规范等
5. 前后端分离，选择合适的 Mock 方案
6. 将最佳实践做成标准项目的脚手架，新项目使用脚手架工具来创建
7. 抽象解决方案，融合到 Webpack 配置中，甚至基于 Webpack 做自己的最佳实践工具链

## 5-Webpack-使用实战

### 5-1-使用-PostCSS-打造移动适配方案

在移动开发初期，常用的移动适配方案是响应式布局，即通过媒体查询(Media Queries)将主流的设备进行分类，根据设备屏幕宽度占比划分出大中小等多个标准尺寸，然后设置不同的尺寸，这样做有两个缺点：

1. 并不能完美适配屏幕
2. 冗余代码较多，写起来还比较麻烦

随着 CSS 标准和浏览器的支持，REM+视口单位(Viewport units)方式越来越成熟，在移动端上可以用来做更好的适配方案

#### 5-1-1 视口单位

简单来说，视口指的是浏览器的可视区域。在桌面设备上，视口指的是浏览器的可视区域；但是移动设备上视口有三个不同的概念值：

- Layout Viewport

  **理想视口**：这是浏览器设置 viewport 元标签(meta)之后定义的一个虚拟布局视口，大小跟 web 页面可呈现的区域有关

- Visual Viewport

  **物理设备的可视区域**：以物理像素来表示，例如 iPhone 6 的物理像素值为 750\*1334

- Ideal Viewport

  **理想视口**：即通常所说的屏幕分辨率，例如 iPhone 6 的屏幕分辨率为 375\*667

> _Tips_：因为 iPhone 6 的屏幕分辨率为 375x667 而实际的物理像素为 750x1334，所以一个分辨率的像素点实际等于 4 个物理像素点，即我们平时说的两倍屏（@2x），即 dpr（Device Pixel Ratio）= 750/375 = 2

视口单位根据设备不同，代表的意义不同。在桌面端，视口单位是浏览器的可视区域来划分的；但在移动端，它指的是布局视口（Layout Viewport）。CSS3 规范中，规定了四个视口单位：

- vw：1vw 等于视口宽度的 1%
- vh：1vh 等于视口高度的 1%
- vmin：选取 vw 和 vh 中最小的那个
- vmax：选取 vw 和 vh 中最大的那个

> _Tips_：视口单位和 % 单位一样吗？视口单位是依赖于视口的尺寸，根据视口尺寸的百分比来定义的，在页面的任意元素 1vw 的值是固定的；而%单位则是依赖于元素的祖先元素，不同的祖先元素，则 1% 值不同

#### 5-1-2-REM-和-REM-布局

rem 是 CSS3 规范中的新单位，顾名思义，rem 是 em 的“变种”，也是一个相对单位，相对的元素是 root 元素，即 html 标签的 font-size 值，比如如果 html 标签的 font-size=14px，则 1rem=14px。

rem 布局指的是页面中固定宽高的元素使用 rem 来标示大小，**rem 的本质是相对的等比例缩放，所以 rem 布局提供了等比例缩放的布局**。

下面是一个示例：

假设拿到一张视觉稿，完成切图之后，需要在不同浏览器上实现等比例缩放。假设视觉稿的宽度可以分为 100 份，每一份用 x 来表示，某个元素根据视觉稿测量得到其宽高为：

```css
.sth {
  width: 400x;
  height: 300x;
}
```

当我们的页面在不同屏幕上进行渲染时，如果上面的 x 单位能够根据不同屏幕自动进行缩放(和视觉稿等比例)，这样我们就不需要写任何兼容性代码来设配不同宽度的屏幕了。此时就可以使用 rem 布局，由于 rem 是根据 root 元素的 font-size 进行变化，所以可以如下设置：

```css
html {
  font-size: screen_width/100;
}
.sth {
  width: 400rem;
  height: 300rem;
}
```

其中，screen_width 指的是当前屏幕的宽度。可以通过使用 js 来动态的设置 html 标签的 font-size，如下：

```javascript
document.documentElement.style.fontSize =
  document.documentElement.clientWidth / 100 + "px";
```

为了应对横屏竖屏的变化，再添加上视口宽度变化和横屏竖屏的事件绑定，当视口宽度发生变化后就会重新设置 html 标签的 font-size，这样就实现了针对不同屏幕的等比例自适应缩放。

#### 5-1-3-使用-vw-rem-postcss-结合实现移动页面适配方案

从上面的示例可以看出，我们通过对屏幕宽度等分 100 份，然后使用 js 来计算出 html 标签的 font-size，而使用 CSS3 的新视口单位：vw 可以省去计算，1vw 就是屏幕宽度的 1/100。

但是实际开发中，vw 的支持没有 rem 好，因此最佳的做法是结合使用 vw 和 rem，支持 vw 的浏览器则直接设置 html 标签的 font-size 为 1vw，不支持的就设置为 clientWidth/100，相当于自己通过 js 计算来实现 vw。然后还可以配合 postcss 插件，直接使用视觉稿的实际尺寸来进行布局计算，而不用手动进行单位换算。

下面最一个移动页面适配方案最佳实践：

```javascript
// 此段代码需要放在html页面的head中
(function (doc, win) {
  // 创建一个元素，检测当前环境是否支持vw
  const dummy = doc.createElement("_").style;
  dummy.width = "1vw";
  if (dummy.width) {
    // 如果支持vw则直接设置html标签的font-size
    doc.documentElement.style.fontSize = "1vw";
    // 如果支持vw，则不需要再进行后续处理
    return;
  }
  // 如果不支持vw，就使用JavaScript来计算font-size
  const docEl = doc.documentElement,
    resizeEvt = "orientationchange" in win ? "orientationchange" : "resize",
    recalc = function () {
      const clientWidth = docEl.clientWidth;
      if (!clientWidth) {
        return;
      }
      docEl.style.fontSize = clientWidth / 100 + "px";
    };
  // 初始化font-size
  recalc();
  // 添加事件绑定
  win.addEventListener(resizeEvt, recalc, false);
})(document, window);
```

在实际项目中，为了区分 rem 和 vw，可以引入一个新的单位：pr，pr 会经过 postcss 处理被转换成对应的 rem，这样就不需要直接写 rem(防止混淆，万一真的要用到 rem 或者 vw，而且也不必手动进行单位换算)。要转换 pr，需要引入一个 postcss 插件：postcss-plugin-pr2rem。

下面是一个示例：

假设拿到一张视觉设计稿，宽度为 1242px，视觉稿上有一个 621px 宽的 div，则可以在 css 中写为：

```css
div {
  width: 621pr;
}
```

然后安装 postcss-plugin-pr2rem：

```bash
npm i -D postcss-plugin-pr2rem
```

接着在 postcss.config.js 中配置 postcss-plugin-pr2rem：

```javascript
// postcss.config.js
const pr2rem = require("postcss-plugin-pr2rem");
const pr2remConfig = {
  // 设计稿为1242px，则一份root对应1242/100=12.42px
  rootValue: 12.42,
  // 这里是基本单位，前面已经配置了1vw
  unitPrecision: 1,
  propWhiteList: [],
  propBlackList: ["font-size"],
  selectorBlackList: [],
  ignoreIdentifier: "00",
  replace: true,
  mediaQuery: false,
  minPixelValue: 0,
};
module.exports = {
  plugins: [pr2rem(pr2remConfig)],
};
```

执行 webpack 打包后，观察代码变化：

```css
/* input */
div {
  width: 621pr;
}
```

```css
/* output */
div {
  width: 50rem;
}
```
